<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XPCShell Test Timings</title>
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <script src="shared.js"></script>
    <link rel="stylesheet" href="shared.css">
    <style>
        .tree-table {
            width: 100%;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .tree-row {
            border-bottom: 1px solid #eee;
            cursor: pointer;
            transition: background-color 0.2s;
            display: flex;
            align-items: center;
            padding: 4px 10px;
            min-height: 28px; /* Ensure consistent height even when empty */
        }

        .tree-row:hover {
            background-color: #f5f5f5;
        }

        .tree-row.expanded {
            background-color: #f0f8ff;
        }

        .tree-name {
            flex: 1;
            font-family: monospace;
            font-size: 13px;
        }

        .tree-stats {
            display: flex;
            gap: 30px;
            font-size: 13px;
        }

        .stat-item {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            text-align: right;
            min-width: 60px;
        }

        .stat-label {
            color: #666;
            font-size: 11px;
            text-transform: uppercase;
        }

        .stat-value {
            font-weight: bold;
            color: #333;
        }

        .stat-value.fail {
            color: #d00;
        }

        .stat-value.skip, .stat-value.zero {
            color: #888;
        }

        .stat-value.timeout {
            color: #f60;
        }

        .folder-icon, .test-icon {
            margin-right: 5px;
        }

        .folder-icon::before {
            content: "üìÅ ";
        }

        .folder-icon.expanded::before {
            content: "üìÇ ";
        }

        .test-icon::before {
            content: "üìÑ ";
        }

        .tree-indent {
            display: inline-block;
            width: 20px;
        }

        .chart-expansion {
            padding: 20px;
            background: #f9f9f9;
            border-top: 1px solid #ddd;
        }

        .controls {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 20px;
            gap: 20px;
        }

        .search-container {
            position: relative;
            display: inline-block;
        }

        .search-box {
            padding: 8px 30px 8px 12px;
            width: 300px;
            box-sizing: border-box;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            flex-shrink: 0;
        }

        .search-clear {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            font-size: 16px;
            color: #999;
            padding: 0;
            width: 20px;
            height: 20px;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .search-clear:hover {
            color: #666;
        }

        .date-selector {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-shrink: 0;
        }

        .status-text {
            font-size: 14px;
            color: #666;
            margin: 0;
            padding: 0;
            vertical-align: baseline;
        }

        .no-data {
            padding: 40px;
            text-align: center;
            color: #666;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .sort-header {
            background: #f8f9fa;
            border-bottom: 2px solid #ddd;
            padding: 10px;
            display: flex;
            align-items: center;
            font-weight: bold;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .sort-header .tree-stats {
            gap: 30px; /* Match the gap from regular tree-stats */
        }

        .sort-header .tree-name {
            color: #666;
        }

        .sort-button {
            background: none;
            border: none;
            cursor: pointer;
            padding: 0;
            margin: 0;
            font-size: 11px;
            text-transform: uppercase;
            color: #666;
            border-radius: 3px;
            transition: background-color 0.2s;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            text-align: right;
            width: 100%;
        }

        .sort-button:hover {
            background-color: #e9ecef;
        }

        .sort-button.active {
            color: #007bff;
            background-color: #e7f3ff;
        }

        .sort-arrow {
            font-size: 10px;
            margin-right: 2px;
            width: 8px;
            display: inline-block;
            text-align: left;
        }

        .tooltip {
            position: relative;
            cursor: help;
        }

        .tooltip .tooltiptext {
            visibility: hidden;
            width: 200px;
            background-color: #2a2a2a;
            color: white;
            text-align: left;
            border-radius: 6px;
            padding: 8px;
            position: absolute;
            z-index: 1000;
            bottom: 125%;
            right: 0;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 12px;
            line-height: 1.4;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .tooltip .tooltiptext::after {
            content: "";
            position: absolute;
            top: 100%;
            right: 20px;
            border-width: 5px;
            border-style: solid;
            border-color: #2a2a2a transparent transparent transparent;
        }

        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }

        .tooltip-platform {
            display: flex;
            justify-content: space-between;
            margin: 2px 0;
        }

        .tooltip-platform-name {
            font-weight: bold;
        }

        .total-row {
            background-color: #f8f9fa;
            border-bottom: 2px solid #ddd;
            font-weight: bold;
        }

        .total-row:hover {
            background-color: #f8f9fa;
        }

        .total-row .tree-name {
            color: #495057;
        }

        .lazy-row .loading {
            color: #999;
            font-style: italic;
        }

        .dynamic-tooltip {
            position: absolute;
            background: #333;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            white-space: nowrap;
            z-index: 1000;
            pointer-events: none;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>XPCShell Test Timings</h1>

        <div class="controls">
            <div class="date-selector">
                <label for="date-select">Select Date: </label>
                <select id="date-select" onchange="loadData()">
                </select>
                <span id="status-text" class="status-text">Loading data...</span>
            </div>
            <div class="date-selector">
                <label>
                    <input type="checkbox" id="list-view" onchange="changeView()">
                    Show as list
                </label>
            </div>
            <div class="search-container">
                <input type="text" class="search-box" id="search-box" placeholder="Search for test paths...">
                <button class="search-clear" id="search-clear" title="Clear search">√ó</button>
            </div>
        </div>
        <div id="error" class="error" style="display: none;"></div>

        <div id="tree-container" style="display: none;">
            <div class="tree-table" id="tree-table"></div>
        </div>

        <div id="no-data" class="no-data" style="display: none;">
            No data available. Click "Fetch New Data" to fetch xpcshell test data.
        </div>
    </div>

    <script>
        let currentData = null;
        let aggregatedData = null;
        let treeData = null;
        let expandedRows = new Set();
        let chartRows = new Set();
        let sortField = 'failCount';
        let sortDirection = 'desc'; // Start with descending for failure count (most failing first)
        let listObserver = null; // Intersection Observer for list view lazy loading

        // Format duration in milliseconds to human readable
        function formatDuration(ms, hasData = true) {
            if (!hasData || ms === 0) {
                return '‚Äî';  // Em dash for no data
            }
            if (ms < 1000) {
                return `${Math.round(ms)}ms`;
            } else if (ms < 60000) {
                return `${(ms / 1000).toFixed(1)}s`;
            } else if (ms < 3600000) {  // Less than 1 hour
                const minutes = Math.floor(ms / 60000);
                const seconds = Math.floor((ms % 60000) / 1000);
                if (seconds === 0) {
                    return `${minutes}m`;
                }
                return `${minutes}m ${seconds}s`;
            } else if (ms < 86400000) {  // Less than 1 day
                const hours = Math.floor(ms / 3600000);
                const minutes = Math.floor((ms % 3600000) / 60000);
                if (minutes === 0) {
                    return `${hours}h`;
                }
                return `${hours}h ${minutes}m`;
            } else {  // Days
                const days = Math.floor(ms / 86400000);
                const hours = Math.floor((ms % 86400000) / 3600000);
                if (hours === 0) {
                    return `${days}d`;
                }
                return `${days}d ${hours}h`;
            }
        }


        // Format numbers with thousand separators
        function formatNumber(num) {
            return num.toLocaleString();
        }

        // Calculate pass percentage with consistent precision
        function calculatePassPercentage(passCount, runCount) {
            if (runCount === 0) return 0;
            return Math.round((passCount / runCount) * 10000) / 100;
        }

        // Generate individual stat item HTML
        function generateStatItem(label, value, valueCssClass = '', containerClass = '', title = '', extraAttrs = '') {
            const titleAttr = title ? ` title="${title}"` : '';
            const containerClassAttr = containerClass ? ` class="stat-item ${containerClass}"` : ' class="stat-item"';
            const valueClassAttr = valueCssClass ? ` class="stat-value ${valueCssClass}"` : ' class="stat-value"';
            return `<div${containerClassAttr}${titleAttr}${extraAttrs}><span class="stat-label">${label}</span><span${valueClassAttr}>${value}</span></div>`;
        }

        // Generate stats HTML for a test (shared between tree and list views)
        function generateStatsHtml(stats, testPath, hasRuns) {
            // Use avgDuration if provided, otherwise calculate it
            const avgDuration = stats.avgDuration !== undefined ? stats.avgDuration :
                (stats.passCount > 0 ? stats.totalDuration / stats.passCount : 0);

            let html = '';
            html += generateStatItem('Avg', formatDuration(avgDuration, hasRuns));
            html += generateStatItem('Max', formatDuration(stats.max, hasRuns));
            html += generateStatItem('Runs', formatNumber(stats.runCount), stats.runCount === 0 ? 'fail' : '', '', `Total duration of passing runs: ${formatDuration(stats.totalDuration, hasRuns)}`);

            const passPercentageClass = stats.passPercentage < 100 && stats.runCount > 0 ? (stats.passPercentage === 0 ? 'fail' : '') : 'zero';
            html += generateStatItem('Pass %', `${stats.passPercentage}%`, passPercentageClass);

            html += generateStatItem('Skips', formatNumber(stats.skipCount), 'skip', stats.skipCount > 0 ? 'lazy-tooltip' : '', '', stats.skipCount > 0 ? ` data-test-path="${testPath}" data-tooltip-type="skips"` : '');

            const failClass = stats.failCount > 0 ? 'fail' : 'zero';
            html += generateStatItem('Failures', formatNumber(stats.failCount), failClass, stats.failCount > 0 ? 'lazy-tooltip' : '', '', stats.failCount > 0 ? ` data-test-path="${testPath}" data-tooltip-type="failures"` : '');

            const timeoutClass = stats.timeoutCount > 0 ? 'timeout' : 'zero';
            html += generateStatItem('Timeouts', formatNumber(stats.timeoutCount), timeoutClass, stats.timeoutCount > 0 ? 'lazy-tooltip' : '', '', stats.timeoutCount > 0 ? ` data-test-path="${testPath}" data-tooltip-type="timeouts"` : '');

            return html;
        }

        // Generate chart HTML structure (shared between tree and list views)
        function generateChartHtml(testPath) {
            const chartIdBase = testPath.replace(/[\/\.]/g, '-');
            return `<div class="chart-expansion"><div id="chart-${chartIdBase}"></div><div id="chart-timeout-${chartIdBase}"></div></div>`;
        }

        // Error display management (shared across all error scenarios)
        function showError(message, showNoData = false) {
            const errorElement = document.getElementById('error');
            errorElement.style.display = 'block';
            errorElement.textContent = message;

            if (showNoData) {
                document.getElementById('no-data').style.display = 'block';
            }
        }

        function hideError() {
            document.getElementById('error').style.display = 'none';
            document.getElementById('no-data').style.display = 'none';
        }

        // Status text management (shared for loading states)
        function setStatusText(text) {
            document.getElementById('status-text').textContent = text;
        }

        // URL hash management
        function updateUrlHash() {
            const date = document.getElementById('date-select').value;
            const search = document.getElementById('search-box').value.trim();
            const listView = document.getElementById('list-view').checked;

            const params = new URLSearchParams();
            if (date) params.set('date', date);
            if (search) params.set('q', search);
            if (listView) params.set('view', 'list');

            const hash = params.toString();
            if (hash) {
                window.location.hash = hash;
            } else {
                history.replaceState(null, '', window.location.pathname);
            }
        }

        // Create test data entries with only testIds - everything computed from global currentData
        function createTestEntries() {
            const testEntries = {};

            if (!currentData.testRuns || !currentData.tables || !currentData.taskInfo || !currentData.testInfo) {
                return testEntries;
            }

            // Create minimal entries for each test with only testId
            for (let testId = 0; testId < currentData.testRuns.length; testId++) {
                const testGroup = currentData.testRuns[testId];
                if (!testGroup) continue;

                const testPath = currentData.tables.testPaths[currentData.testInfo.testPathIds[testId]];
                const testName = currentData.tables.testNames[currentData.testInfo.testNameIds[testId]];
                const fullPath = testPath ? `${testPath}/${testName}` : testName;

                testEntries[fullPath] = {
                    testId: testId
                };
            }

            return testEntries;
        }

        // Compute statistics for a single test from global currentData
        function computeTestStats(testId) {
            const testGroup = currentData.testRuns[testId];

            if (!testGroup) {
                return {
                    runCount: 0,
                    skipCount: 0,
                    passCount: 0,
                    failCount: 0,
                    timeoutCount: 0,
                    passPercentage: 0,
                    max: 0,
                    avg: 0
                };
            }

            let skipCount = 0;
            let timeoutCount = 0;
            let failCount = 0;
            let passCount = 0;
            let maxDuration = 0;
            let totalDuration = 0;

            // Process each status group within this test
            for (let statusId = 0; statusId < testGroup.length; statusId++) {
                const statusGroup = testGroup[statusId];
                if (!statusGroup) continue;

                const status = currentData.tables.statuses[statusId];
                const runCount = statusGroup.taskIdIds.length;

                const isSkip = status === 'SKIP';
                const isTimeout = status === 'TIMEOUT';
                const isFail = status && status !== 'PASS' && status !== 'SKIP' && status !== 'TIMEOUT' && status !== 'EXPECTED-FAIL';

                // Add counts for this status group
                if (isSkip) {
                    skipCount += runCount;
                } else if (isTimeout) {
                    timeoutCount += runCount;
                } else if (status === 'UNKNOWN') {
                    // Split UNKNOWN by duration: skips, timeouts, or passes
                    for (const duration of statusGroup.durations) {
                        if (duration < 100) {
                            skipCount++;
                        } else if (duration > 300000) {
                            timeoutCount++;
                        } else {
                            passCount++;
                            totalDuration += duration;
                            if (duration > maxDuration) {
                                maxDuration = duration;
                            }
                        }
                    }
                } else if (isFail) {
                    failCount += runCount;
                } else {
                    // PASS or EXPECTED-FAIL
                    passCount += runCount;
                    for (const duration of statusGroup.durations) {
                        totalDuration += duration;
                        if (duration > maxDuration) {
                            maxDuration = duration;
                        }
                    }
                }
            }

            const runCount = skipCount + timeoutCount + failCount + passCount - skipCount; // Total minus skips

            return {
                runCount: runCount,
                skipCount: skipCount,
                passCount: passCount,
                timeoutCount: timeoutCount,
                failCount: failCount,
                passPercentage: calculatePassPercentage(passCount, runCount),
                max: maxDuration,
                totalDuration: totalDuration
            };
        }

        // Lazy function to get platforms for a test
        function getTestPlatforms(testPath) {
            const testData = aggregatedData[testPath];
            if (!testData) return [];

            if (testData.platforms) {
                return testData.platforms;
            }

            const platforms = new Set();
            const testGroup = currentData.testRuns[testData.testId];

            if (testGroup) {
                // Process each status group to collect platforms
                for (let statusId = 0; statusId < testGroup.length; statusId++) {
                    const statusGroup = testGroup[statusId];
                    if (!statusGroup) continue;

                    for (let i = 0; i < statusGroup.taskIdIds.length; i++) {
                        const taskIdIndex = statusGroup.taskIdIds[i];
                        const jobName = currentData.tables.jobNames[currentData.taskInfo.jobNameIds[taskIdIndex]];
                        platforms.add(extractPlatform(jobName) || 'unknown');
                    }
                }
            }

            // Cache platforms
            testData.platforms = Array.from(platforms);
            return testData.platforms;
        }

        // Lazy function to create run objects only when needed for charts
        function getTestRuns(testPath) {
            const testData = aggregatedData[testPath];
            if (!testData || testData.runs) {
                // Already computed or no data
                return testData?.runs || [];
            }

            const testGroup = currentData.testRuns[testData.testId];
            const runs = [];
            const startTime = (currentData.metadata.startTime || 0) * 1000; // Convert seconds to ms

            if (!testGroup) return runs;

            // Process each status group for this test
            for (let statusId = 0; statusId < testGroup.length; statusId++) {
                const statusGroup = testGroup[statusId];
                if (!statusGroup) continue;

                const status = currentData.tables.statuses[statusId];
                const runCount = statusGroup.taskIdIds.length;

                // Decompress differential timestamps back to absolute values
                const decompressedTimestamps = [];
                if (statusGroup.timestamps.length > 0) {
                    let currentTimestamp = 0;
                    for (let i = 0; i < statusGroup.timestamps.length; i++) {
                        currentTimestamp += statusGroup.timestamps[i];
                        decompressedTimestamps.push(currentTimestamp);
                    }
                }

                for (let i = 0; i < runCount; i++) {
                    const duration = statusGroup.durations[i];
                    const taskIdIndex = statusGroup.taskIdIds[i];
                    const taskIdString = currentData.tables.taskIds[taskIdIndex];
                    const jobName = currentData.tables.jobNames[currentData.taskInfo.jobNameIds[taskIdIndex]];

                    runs.push({
                        duration: duration,
                        repository: currentData.tables.repositories[currentData.taskInfo.repositoryIds[taskIdIndex]],
                        jobName: jobName,
                        taskIdString: taskIdString,
                        status: status,
                        timestamp: startTime + (decompressedTimestamps[i] * 1000), // Convert relative seconds to absolute ms
                        isFail: status && status !== 'PASS' && status !== 'SKIP' && status !== 'TIMEOUT' && status !== 'EXPECTED-FAIL',
                        isSkip: status === 'SKIP',
                        isTimeout: status === 'TIMEOUT' || (status === 'UNKNOWN' && duration > 300000)
                    });
                }
            }

            // Cache the runs for future use
            testData.runs = runs;
            return runs;
        }

        // Build tree structure from test entries, computing statistics directly from raw data
        function buildTreeStructure(testEntries) {
            const tree = {
                name: 'root',
                path: '',
                children: {},
                tests: {}
            };

            for (const testPath in testEntries) {
                const parts = testPath.split('/');
                let currentNode = tree;

                // Navigate/create folder structure
                for (let i = 0; i < parts.length - 1; i++) {
                    const folder = parts[i];

                    if (!currentNode.children[folder]) {
                        currentNode.children[folder] = {
                            name: folder,
                            path: parts.slice(0, i + 1).join('/'),
                            children: {},
                            tests: {}
                        };
                    }

                    currentNode = currentNode.children[folder];
                }

                // Compute test statistics from global currentData
                const testData = testEntries[testPath];
                const testStats = computeTestStats(testData.testId);

                // Add computed stats to test data
                testData.stats = testStats;

                // Add test to the final folder
                const testName = parts[parts.length - 1];
                currentNode.tests[testName] = {
                    name: testName,
                    path: testPath,
                    data: testData
                };
            }

            // Note: Folder stats are now computed on-demand by calculateFilteredStats
            return tree;
        }

        // Sort function
        function sortItems(items, isFolder, node) {
            return items.sort((a, b) => {
                let valueA, valueB;

                if (isFolder) {
                    // Compute stats on-demand for sorting
                    const nodeA = (typeof a === 'string') ? node.children[a] : a;
                    const nodeB = (typeof b === 'string') ? node.children[b] : b;
                    const statsA = calculateFilteredStats(nodeA, ''); // No search term = all stats
                    const statsB = calculateFilteredStats(nodeB, ''); // No search term = all stats

                    switch(sortField) {
                        case 'name':
                            valueA = (typeof a === 'string') ? a : a.name || '';
                            valueB = (typeof b === 'string') ? b : b.name || '';
                            return sortDirection === 'asc' ? valueA.localeCompare(valueB) : valueB.localeCompare(valueA);
                        case 'testCount':
                            valueA = statsA.testCount || 0;
                            valueB = statsB.testCount || 0;
                            break;
                        case 'runCount':
                            valueA = statsA.runCount || 0;
                            valueB = statsB.runCount || 0;
                            break;
                        case 'passPercentage':
                            valueA = parseFloat(statsA.passPercentage) || 0;
                            valueB = parseFloat(statsB.passPercentage) || 0;
                            break;
                        case 'skipCount':
                            valueA = statsA.skipCount || 0;
                            valueB = statsB.skipCount || 0;
                            break;
                        case 'failCount':
                            valueA = statsA.failCount || 0;
                            valueB = statsB.failCount || 0;
                            break;
                        case 'timeoutCount':
                            valueA = statsA.timeoutCount || 0;
                            valueB = statsB.timeoutCount || 0;
                            break;
                        default:
                            valueA = parseFloat(statsA.passPercentage) || 0;
                            valueB = parseFloat(statsB.passPercentage) || 0;
                    }
                } else {
                    const statsA = (typeof a === 'string') ? node.tests[a].data.stats : a.data.stats;
                    const statsB = (typeof b === 'string') ? node.tests[b].data.stats : b.data.stats;

                    switch(sortField) {
                        case 'name':
                            valueA = (typeof a === 'string') ? a : a.name || '';
                            valueB = (typeof b === 'string') ? b : b.name || '';
                            return sortDirection === 'asc' ? valueA.localeCompare(valueB) : valueB.localeCompare(valueA);
                        case 'avg':
                            valueA = statsA.passCount > 0 ? statsA.totalDuration / statsA.passCount : 0;
                            valueB = statsB.passCount > 0 ? statsB.totalDuration / statsB.passCount : 0;
                            break;
                        case 'max':
                            valueA = statsA.max || 0;
                            valueB = statsB.max || 0;
                            break;
                        case 'runCount':
                            valueA = statsA.runCount || 0;
                            valueB = statsB.runCount || 0;
                            break;
                        case 'passPercentage':
                            valueA = parseFloat(statsA.passPercentage) || 0;
                            valueB = parseFloat(statsB.passPercentage) || 0;
                            break;
                        case 'skipCount':
                            valueA = statsA.skipCount || 0;
                            valueB = statsB.skipCount || 0;
                            break;
                        case 'failCount':
                            valueA = statsA.failCount || 0;
                            valueB = statsB.failCount || 0;
                            break;
                        case 'timeoutCount':
                            valueA = statsA.timeoutCount || 0;
                            valueB = statsB.timeoutCount || 0;
                            break;
                        default:
                            valueA = parseFloat(statsA.passPercentage) || 0;
                            valueB = parseFloat(statsB.passPercentage) || 0;
                    }
                }

                const result = sortDirection === 'asc' ? valueA - valueB : valueB - valueA;
                return result;
            });
        }

        // Build sort header
        function buildSortHeader() {
            const getSortButton = ([field, label]) => {
                const isActive = sortField === field;
                const arrow = isActive ? (sortDirection === 'asc' ? '‚Üë' : '‚Üì') : ' '; // Always show space
                return `<div class="stat-item">
                    <button class="sort-button ${isActive ? 'active' : ''}" data-field="${field}" onclick="changeSortOrder('${field}')">
                        <span class="sort-arrow">${arrow}</span>${label}
                    </button>
                </div>`;
            };

            // Check if we're in list view or if we have tests to show appropriate headers
            const listViewCheckbox = document.getElementById('list-view');
            const isListView = listViewCheckbox && listViewCheckbox.checked;
            const hasTests = isListView || (treeData && Object.values(treeData.children).some(folder => Object.keys(folder.tests).length > 0));

            // Special button for Path (left-aligned)
            const getPathButton = (field, label) => {
                const isActive = sortField === field;
                const arrow = isActive ? (sortDirection === 'asc' ? '‚Üë' : '‚Üì') : ' '; // Always show space
                return `<button class="sort-button ${isActive ? 'active' : ''}" data-field="${field}" onclick="changeSortOrder('${field}')" style="justify-content: flex-start;">
                    <span class="sort-arrow">${arrow}</span>${label}
                </button>`;
            };

            // Generate appropriate stats buttons based on view type
            const commonFields = [['runCount', 'Runs'], ['passPercentage', 'Pass %'], ['skipCount', 'Skips'], ['failCount', 'Failures'], ['timeoutCount', 'Timeouts']];
            const specificFields = hasTests ? [['avg', 'Avg'], ['max', 'Max']] : [['testCount', 'Tests']];
            const statsFields = [...specificFields, ...commonFields];

            const statsButtons = statsFields.map(getSortButton).join('');

            return `<div class="sort-header">
                <div class="tree-name">${getPathButton('name', 'Path')}</div>
                <div class="tree-stats">
                    ${statsButtons}
                </div>
            </div>`;
        }

        // Change sort order
        function changeSortOrder(field) {
            if (sortField === field) {
                sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                sortField = field;
                // Default to descending for most fields, ascending for path and pass percentage
                if (field === 'name' || field === 'passPercentage') {
                    sortDirection = 'asc';
                } else {
                    sortDirection = 'desc';
                }
            }
            changeView();
        }

        // Calculate platform breakdown for test data
        function calculateTestPlatformBreakdown(testData) {
            const platforms = {};

            // Use global currentData to avoid creating run objects just for tooltips
            if (testData.testId !== undefined) {
                const testGroup = currentData.testRuns[testData.testId];

                if (testGroup) {
                    // Process each status group
                    for (let statusId = 0; statusId < testGroup.length; statusId++) {
                        const statusGroup = testGroup[statusId];
                        if (!statusGroup) continue;

                        const status = currentData.tables.statuses[statusId];
                        const isSkip = status === 'SKIP';
                        const isTimeout = status === 'TIMEOUT';
                        const isFail = status && status !== 'PASS' && status !== 'SKIP' && status !== 'TIMEOUT' && status !== 'EXPECTED-FAIL';

                        for (let i = 0; i < statusGroup.taskIdIds.length; i++) {
                            const taskIdIndex = statusGroup.taskIdIds[i];
                            const jobName = currentData.tables.jobNames[currentData.taskInfo.jobNameIds[taskIdIndex]];
                            const platform = extractPlatform(jobName) || 'unknown';
                            const duration = statusGroup.durations[i];
                            const isTimeoutByDuration = status === 'UNKNOWN' && duration > 300000;

                            if (!platforms[platform]) {
                                platforms[platform] = {
                                    total: 0,
                                    skips: 0,
                                    failures: 0,
                                    timeouts: 0,
                                    passes: 0
                                };
                            }

                            platforms[platform].total++;
                            if (isSkip) {
                                platforms[platform].skips++;
                            } else if (isTimeout || isTimeoutByDuration) {
                                platforms[platform].timeouts++;
                            } else if (isFail) {
                                platforms[platform].failures++;
                            } else {
                                platforms[platform].passes++;
                            }
                        }
                    }
                }
            } else if (testData.runs) {
                // Fall back to runs if raw data is no longer available
                testData.runs.forEach(run => {
                    const platform = extractPlatform(run.jobName) || 'unknown';
                    if (!platforms[platform]) {
                        platforms[platform] = {
                            total: 0,
                            skips: 0,
                            failures: 0,
                            timeouts: 0,
                            passes: 0
                        };
                    }

                    platforms[platform].total++;
                    if (run.isSkip) {
                        platforms[platform].skips++;
                    } else if (run.isTimeout) {
                        platforms[platform].timeouts++;
                    } else if (run.isFail) {
                        platforms[platform].failures++;
                    } else {
                        platforms[platform].passes++;
                    }
                });
            }

            return platforms;
        }

        // Calculate platform breakdown for folder data (recursive)
        function calculateFolderPlatformBreakdown(node) {
            const platforms = {};

            // Collect from tests
            Object.values(node.tests).forEach(test => {
                const testBreakdown = calculateTestPlatformBreakdown(test.data);
                Object.entries(testBreakdown).forEach(([platform, counts]) => {
                    if (!platforms[platform]) {
                        platforms[platform] = { skips: 0, failures: 0, timeouts: 0, passes: 0, total: 0 };
                    }
                    platforms[platform].skips += counts.skips;
                    platforms[platform].failures += counts.failures;
                    platforms[platform].timeouts += counts.timeouts;
                    platforms[platform].passes += counts.passes;
                    platforms[platform].total += counts.total;
                });
            });

            // Collect from child folders
            Object.values(node.children).forEach(child => {
                const childBreakdown = calculateFolderPlatformBreakdown(child);
                Object.entries(childBreakdown).forEach(([platform, counts]) => {
                    if (!platforms[platform]) {
                        platforms[platform] = { skips: 0, failures: 0, timeouts: 0, passes: 0, total: 0 };
                    }
                    platforms[platform].skips += counts.skips;
                    platforms[platform].failures += counts.failures;
                    platforms[platform].timeouts += counts.timeouts;
                    platforms[platform].passes += counts.passes;
                    platforms[platform].total += counts.total;
                });
            });

            return platforms;
        }

        // Generate tooltip content for platform breakdown
        function generateTooltipContent(platforms, type) {
            const sortedPlatforms = Object.entries(platforms)
                .filter(([platform, counts]) => counts[type] > 0)
                .sort(([,a], [,b]) => b[type] - a[type]);

            if (sortedPlatforms.length === 0) {
                return '';
            }

            const total = sortedPlatforms.reduce((sum, [,counts]) => sum + counts[type], 0);
            const typeLabel = type === 'failures' ? 'Failures' : type === 'skips' ? 'Skips' : 'Timeouts';

            let content = `<strong>${typeLabel} by Platform:</strong><br/>`;
            sortedPlatforms.forEach(([platform, counts]) => {
                const platformName = platforms[platform] || platform;
                const percentage = ((counts[type] / total) * 100).toFixed(1);
                content += `<div class="tooltip-platform">`;
                content += `<span class="tooltip-platform-name">${platform}:</span>`;
                content += `<span>${counts[type]} (${percentage}%)</span>`;
                content += `</div>`;
            });

            return content;
        }

        // Build total summary row
        function buildTotalSummaryRow(totalStats) {
            // Tooltips will be computed lazily on hover

            let html = `<div class="tree-row total-row">`;
            html += `<div class="tree-name"><strong>üìä Total</strong></div>`;
            html += `<div class="tree-stats">`;

            // Check if we're showing test-specific columns or folder-specific columns
            const hasTests = treeData && Object.values(treeData.children).some(folder => Object.keys(folder.tests).length > 0);

            if (hasTests) {
                // Test view: show avg/max columns
                html += generateStatItem('Avg', '‚Äî');
                html += generateStatItem('Max', '‚Äî');
            } else {
                // Folder view: show test count
                html += generateStatItem('Tests', formatNumber(totalStats.testCount));
            }

            html += generateStatItem('Runs', formatNumber(totalStats.runCount), totalStats.runCount === 0 ? 'fail' : '', '', `Total duration of passing runs: ${formatDuration(totalStats.totalDuration, totalStats.runCount > 0)}`);

            const totalPassPercentageClass = totalStats.passPercentage < 100 && totalStats.runCount > 0 ? (totalStats.passPercentage === 0 ? 'fail' : '') : 'zero';
            html += generateStatItem('Pass %', `${totalStats.passPercentage}%`, totalPassPercentageClass);

            // Skips with lazy tooltip
            html += generateStatItem('Skips', formatNumber(totalStats.skipCount), 'skip', totalStats.skipCount > 0 ? 'lazy-tooltip' : '', '', ' data-total-root="true" data-tooltip-type="skips"');

            // Failures with lazy tooltip
            const totalFailClass = totalStats.failCount > 0 ? 'fail' : 'zero';
            html += generateStatItem('Failures', formatNumber(totalStats.failCount), totalFailClass, totalStats.failCount > 0 ? 'lazy-tooltip' : '', '', ' data-total-root="true" data-tooltip-type="failures"');

            // Timeouts with lazy tooltip
            const totalTimeoutClass = totalStats.timeoutCount > 0 ? 'timeout' : 'zero';
            html += generateStatItem('Timeouts', formatNumber(totalStats.timeoutCount), totalTimeoutClass, totalStats.timeoutCount > 0 ? 'lazy-tooltip' : '', '', ' data-total-root="true" data-tooltip-type="timeouts"');

            html += `</div>`;
            html += `</div>`;

            return html;
        }

        // Check if a node or its children contain matches
        function containsMatch(node, searchTerm, currentPath = '') {
            if (!searchTerm) return true;

            const lowerSearch = searchTerm.toLowerCase();

            // Check tests in this node
            for (const testName of Object.keys(node.tests)) {
                const fullPath = currentPath ? `${currentPath}/${testName}` : testName;
                if (fullPath.toLowerCase().includes(lowerSearch)) {
                    return true;
                }
            }

            // Check child folders recursively
            for (const childName of Object.keys(node.children)) {
                const childPath = currentPath ? `${currentPath}/${childName}` : childName;
                if (containsMatch(node.children[childName], searchTerm, childPath)) {
                    return true;
                }
            }

            return false;
        }

        // Calculate filtered statistics for search results
        function calculateFilteredStats(node, searchTerm, currentPath = '') {
            let filteredStats = {
                testCount: 0,
                runCount: 0,
                passCount: 0,
                skipCount: 0,
                failCount: 0,
                timeoutCount: 0,
                passPercentage: 0,
                totalDuration: 0
            };

            // Count tests that match the search (or all tests if no search term)
            for (const testName of Object.keys(node.tests)) {
                const fullPath = currentPath ? `${currentPath}/${testName}` : testName;
                const matchesSearch = !searchTerm || fullPath.toLowerCase().includes(searchTerm.toLowerCase());

                if (matchesSearch) {
                    const test = node.tests[testName];
                    const testData = aggregatedData[test.path];
                    if (testData) {
                        filteredStats.testCount++;
                        filteredStats.runCount += testData.stats.runCount;
                        filteredStats.passCount += testData.stats.passCount;
                        filteredStats.skipCount += testData.stats.skipCount;
                        filteredStats.failCount += testData.stats.failCount;
                        filteredStats.timeoutCount += testData.stats.timeoutCount;
                        filteredStats.totalDuration += testData.stats.totalDuration || 0;
                    }
                }
            }

            // Recursively include stats from child folders that contain matches (or all if no search)
            for (const childName of Object.keys(node.children)) {
                const childPath = currentPath ? `${currentPath}/${childName}` : childName;
                const shouldIncludeChild = !searchTerm || containsMatch(node.children[childName], searchTerm, childPath);

                if (shouldIncludeChild) {
                    const childStats = calculateFilteredStats(node.children[childName], searchTerm, childPath);
                    filteredStats.testCount += childStats.testCount;
                    filteredStats.runCount += childStats.runCount;
                    filteredStats.passCount += childStats.passCount;
                    filteredStats.skipCount += childStats.skipCount;
                    filteredStats.failCount += childStats.failCount;
                    filteredStats.timeoutCount += childStats.timeoutCount;
                    filteredStats.totalDuration += childStats.totalDuration || 0;
                }
            }

            // Calculate pass percentage
            filteredStats.passPercentage = calculatePassPercentage(filteredStats.passCount, filteredStats.runCount);

            return filteredStats;
        }

        // Build HTML for tree rows
        function buildTreeHTML(node, level = 0, parentPath = '', searchTerm = '') {
            let html = '';
            const lowerSearchTerm = searchTerm.toLowerCase();

            // Add header only at root level
            if (level === 0) {
                html += buildSortHeader();
                // Add total summary row - always use calculateFilteredStats (works for both filtered and unfiltered)
                const statsToShow = calculateFilteredStats(node, searchTerm);
                html += buildTotalSummaryRow(statsToShow);
            }

            // Sort folders
            const sortedFolders = sortItems(Object.keys(node.children), true, node);

            // Build rows for folders
            for (const folderName of sortedFolders) {
                let folder = node.children[folderName];
                let displayName = folderName;
                let collapsedPath = folderName;

                // Skip folder if it doesn't contain matches
                if (searchTerm && !containsMatch(folder, searchTerm, parentPath ? `${parentPath}/${folderName}` : folderName)) {
                    continue;
                }

                // Collapse single-child folders into one line
                while (Object.keys(folder.children).length === 1 && Object.keys(folder.tests).length === 0) {
                    const childName = Object.keys(folder.children)[0];
                    collapsedPath = `${collapsedPath}/${childName}`;
                    displayName = `${displayName}/${childName}`;
                    folder = folder.children[childName];
                }

                const folderPath = parentPath ? `${parentPath}/${collapsedPath}` : collapsedPath;
                const isExpanded = expandedRows.has(folderPath);

                // Always use calculateFilteredStats (works for both filtered and unfiltered)
                const folderStats = calculateFilteredStats(folder, searchTerm, folderPath);

                html += `<div class="tree-row folder-row" data-path="${folderPath}" data-level="${level}">`;
                html += `<div class="tree-name">`;
                html += `<span class="tree-indent" style="width: ${level * 20}px"></span>`;
                html += `<span class="folder-icon ${isExpanded ? 'expanded' : ''}"></span>`;
                html += `<strong>${displayName}/</strong>`;
                html += `</div>`;
                html += `<div class="tree-stats">`;
                html += generateStatItem('Tests', formatNumber(folderStats.testCount));
                html += generateStatItem('Runs', formatNumber(folderStats.runCount), folderStats.runCount === 0 ? 'fail' : '', '', `Total duration of passing runs: ${formatDuration(folderStats.totalDuration, folderStats.runCount > 0)}`);

                const folderPassPercentageClass = folderStats.passPercentage < 100 && folderStats.runCount > 0 ? (folderStats.passPercentage === 0 ? 'fail' : '') : 'zero';
                html += generateStatItem('Pass %', `${folderStats.passPercentage}%`, folderPassPercentageClass);

                // Skips with lazy tooltip
                html += generateStatItem('Skips', formatNumber(folderStats.skipCount), 'skip', folderStats.skipCount > 0 ? 'lazy-tooltip' : '', '', ` data-folder-path="${folderPath}" data-tooltip-type="skips"`);

                // Failures with lazy tooltip
                const folderFailClass = folderStats.failCount > 0 ? 'fail' : 'zero';
                html += generateStatItem('Failures', formatNumber(folderStats.failCount), folderFailClass, folderStats.failCount > 0 ? 'lazy-tooltip' : '', '', ` data-folder-path="${folderPath}" data-tooltip-type="failures"`);

                // Timeouts with lazy tooltip
                const folderTimeoutClass = folderStats.timeoutCount > 0 ? 'timeout' : 'zero';
                html += generateStatItem('Timeouts', formatNumber(folderStats.timeoutCount), folderTimeoutClass, folderStats.timeoutCount > 0 ? 'lazy-tooltip' : '', '', ` data-folder-path="${folderPath}" data-tooltip-type="timeouts"`);

                html += `</div>`;
                html += `</div>`;

                if (isExpanded) {
                    html += buildTreeHTML(folder, level + 1, folderPath, searchTerm);
                }
            }

            // Sort tests
            const sortedTests = sortItems(Object.keys(node.tests), false, node);

            // Build rows for tests
            for (const testName of sortedTests) {
                const test = node.tests[testName];
                const testPath = test.path;

                // Skip test if it doesn't match search
                if (searchTerm && !testPath.toLowerCase().includes(lowerSearchTerm)) {
                    continue;
                }
                const hasChart = chartRows.has(testPath);

                html += `<div class="tree-row test-row" data-path="${testPath}" data-level="${level}">`;
                html += `<div class="tree-name">`;
                html += `<span class="tree-indent" style="width: ${level * 20}px"></span>`;
                html += `<span class="test-icon"></span>`;
                html += `${testName}`;
                html += `</div>`;
                html += `<div class="tree-stats">`;
                const hasRuns = test.data.stats.runCount > 0;
                html += generateStatsHtml(test.data.stats, testPath, hasRuns);
                html += `</div>`;
                html += `</div>`;

                if (hasChart) {
                    html += generateChartHtml(testPath);
                }

            }

            return html;
        }

        // Render list view of all tests
        function renderListView() {
            if (!aggregatedData) {
                document.getElementById('no-data').style.display = 'block';
                document.getElementById('tree-container').style.display = 'none';
                return;
            }

            hideError();
            document.getElementById('tree-container').style.display = 'block';

            // Get search term for filtering
            const searchTerm = document.getElementById('search-box').value.toLowerCase().trim();

            // Convert aggregated data to array and calculate metrics
            let testList = Object.entries(aggregatedData).map(([testPath, testData]) => {
                const stats = testData.stats;
                const avgDuration = stats.passCount > 0 ? stats.totalDuration / stats.passCount : 0;
                const totalFailures = stats.failCount + stats.timeoutCount; // Count timeouts as failures
                return {
                    testPath,
                    stats,
                    avgDuration,
                    totalFailures
                };
            }).filter(test => test.stats.runCount > 0 || test.stats.skipCount > 0); // Include tests with runs or skips

            // Apply search filtering if search term exists
            if (searchTerm) {
                testList = testList.filter(test => test.testPath.toLowerCase().includes(searchTerm));
            }

            // Apply sorting based on current sortField and sortDirection
            testList.sort((a, b) => {
                let valueA, valueB;

                switch(sortField) {
                    case 'name':
                        valueA = a.testPath;
                        valueB = b.testPath;
                        break;
                    case 'avg':
                        valueA = a.avgDuration;
                        valueB = b.avgDuration;
                        break;
                    case 'max':
                        valueA = a.stats.max || 0;
                        valueB = b.stats.max || 0;
                        break;
                    case 'runCount':
                        valueA = a.stats.runCount || 0;
                        valueB = b.stats.runCount || 0;
                        break;
                    case 'passPercentage':
                        valueA = parseFloat(a.stats.passPercentage) || 0;
                        valueB = parseFloat(b.stats.passPercentage) || 0;
                        break;
                    case 'skipCount':
                        valueA = a.stats.skipCount || 0;
                        valueB = b.stats.skipCount || 0;
                        break;
                    case 'failCount':
                        valueA = a.stats.failCount || 0;
                        valueB = b.stats.failCount || 0;
                        break;
                    case 'timeoutCount':
                        valueA = a.stats.timeoutCount || 0;
                        valueB = b.stats.timeoutCount || 0;
                        break;
                    default:
                        // Default sort by total failures (failCount + timeoutCount)
                        valueA = a.totalFailures;
                        valueB = b.totalFailures;
                        break;
                }

                if (sortField === 'name') {
                    return sortDirection === 'asc' ? valueA.localeCompare(valueB) : valueB.localeCompare(valueA);
                }

                return sortDirection === 'asc' ? valueA - valueB : valueB - valueA;
            });

            let html = '<div class="tree-table">';
            html += buildSortHeader();

            // Calculate how many rows to render immediately (viewport + buffer)
            const rowHeight = 28; // From CSS min-height
            const viewportHeight = window.innerHeight;
            const visibleRows = Math.ceil(viewportHeight / rowHeight);
            const bufferRows = 5; // Extra rows for smooth scrolling
            const preRenderCount = Math.min(visibleRows + bufferRows, testList.length);

            // Create rows with immediate rendering for viewport, lazy loading for the rest
            testList.forEach((test, index) => {
                const shouldPreRender = index < preRenderCount;

                html += `<div class="tree-row test-row ${shouldPreRender ? 'list-row' : 'lazy-row'}" data-path="${test.testPath}" data-level="0" data-test-index="${index}">`;

                if (shouldPreRender) {
                    // Render immediately for visible rows
                    const hasRuns = test.stats.runCount > 0;
                    html += `<div class="tree-name">`;
                    html += `<span class="test-icon"></span>`;
                    html += test.testPath;
                    html += `</div>`;
                    html += `<div class="tree-stats">`;
                    // Use avgDuration from test object, not recalculated
                    const statsWithAvgDuration = { ...test.stats, avgDuration: test.avgDuration };
                    html += generateStatsHtml(statsWithAvgDuration, test.testPath, hasRuns);
                    html += `</div>`;
                } else {
                    // Empty structure for lazy loading
                    html += `<div class="tree-name"></div>`;
                    html += `<div class="tree-stats"></div>`;
                }

                html += `</div>`;
            });

            html += '</div>';

            document.getElementById('tree-table').innerHTML = html;

            // Add click handlers to all list rows (both pre-rendered and lazy)
            document.querySelectorAll('.test-row').forEach(row => {
                row.addEventListener('click', (e) => {
                    toggleTestChart(row);
                });
            });

            // Add tooltip handlers to pre-rendered rows
            document.querySelectorAll('.lazy-tooltip').forEach(element => {
                element.addEventListener('mouseenter', handleTooltipMouseEnter);
                element.addEventListener('mouseleave', handleTooltipMouseLeave);
            });

            // Set up Intersection Observer for lazy loading
            setupListObserver(testList);
        }

        // Set up Intersection Observer for lazy loading list rows
        function setupListObserver(testList) {
            // Clean up existing observer
            if (listObserver) {
                listObserver.disconnect();
            }

            // Create new observer with some margin for smoother loading
            listObserver = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const row = entry.target;
                        const testIndex = parseInt(row.dataset.testIndex);
                        const test = testList[testIndex];

                        if (test && row.classList.contains('lazy-row')) {
                            // Render the actual content
                            renderListRowContent(row, test);
                            // Remove from observation since it's now loaded
                            listObserver.unobserve(row);
                        }
                    }
                });
            }, {
                root: null, // Use viewport as root
                rootMargin: '200px', // Load rows 200px before they become visible
                threshold: 0 // Trigger as soon as any part becomes visible
            });

            // Observe all lazy rows
            document.querySelectorAll('.lazy-row').forEach(row => {
                listObserver.observe(row);
            });
        }

        // Render content for a specific list row
        function renderListRowContent(row, test) {
            const hasRuns = test.stats.runCount > 0;

            // Update the tree-name content
            const treeName = row.querySelector('.tree-name');
            treeName.innerHTML = `
                <span class="test-icon"></span>
                ${test.testPath}
            `;

            // Update the tree-stats content
            const treeStats = row.querySelector('.tree-stats');
            const statsWithAvgDuration = { ...test.stats, avgDuration: test.avgDuration };
            treeStats.innerHTML = generateStatsHtml(statsWithAvgDuration, test.testPath, hasRuns);

            // Remove lazy-row class to indicate it's loaded
            row.classList.remove('lazy-row');

            // Add tooltip handlers for this row
            row.querySelectorAll('.lazy-tooltip').forEach(element => {
                element.addEventListener('mouseenter', handleTooltipMouseEnter);
                element.addEventListener('mouseleave', handleTooltipMouseLeave);
            });

            // Add chart if expanded
            const hasChart = chartRows.has(test.testPath);
            if (hasChart) {
                row.insertAdjacentHTML('afterend', generateChartHtml(test.testPath));

                // Render the chart
                renderChart(test.testPath);
            }
        }

        // Render the tree
        function renderTree() {
            // Clean up list observer when switching to tree view
            if (listObserver) {
                listObserver.disconnect();
                listObserver = null;
            }

            if (!treeData) {
                document.getElementById('no-data').style.display = 'block';
                document.getElementById('tree-container').style.display = 'none';
                return;
            }

            hideError();
            document.getElementById('tree-container').style.display = 'block';

            const searchTerm = document.getElementById('search-box').value.trim();

            // Auto-expand folders if there's a search term and no folders are currently expanded
            if (searchTerm && expandedRows.size === 0) {
                autoExpandForSearch(searchTerm);
            }

            const treeHTML = buildTreeHTML(treeData, 0, '', searchTerm);
            document.getElementById('tree-table').innerHTML = treeHTML;

            // Add click handlers
            document.querySelectorAll('.folder-row').forEach(row => {
                row.addEventListener('click', () => toggleFolder(row));
            });

            document.querySelectorAll('.test-row').forEach(row => {
                row.addEventListener('click', () => toggleTestChart(row));
            });

            // Re-render any open charts
            chartRows.forEach(testPath => {
                renderChart(testPath);
            });

            // Add lazy tooltip handlers
            document.querySelectorAll('.lazy-tooltip').forEach(element => {
                element.addEventListener('mouseenter', handleTooltipMouseEnter);
                element.addEventListener('mouseleave', handleTooltipMouseLeave);
            });
        }

        // Handle tooltip mouse enter event
        function handleTooltipMouseEnter(event) {
            const element = event.target;
            const tooltipType = element.dataset.tooltipType;

            // Determine the data source
            let platformBreakdown;
            if (element.dataset.totalRoot) {
                // Total row - calculate for entire tree
                platformBreakdown = treeData ? calculateFolderPlatformBreakdown(treeData) : {};
            } else if (element.dataset.folderPath) {
                // Folder - find the folder node and calculate breakdown
                const folderPath = element.dataset.folderPath;
                const folderNode = findFolderNode(treeData, folderPath);
                platformBreakdown = folderNode ? calculateFolderPlatformBreakdown(folderNode) : {};
            } else if (element.dataset.testPath) {
                // Test - get the test data and calculate breakdown
                const testPath = element.dataset.testPath;
                const testData = aggregatedData[testPath];
                platformBreakdown = testData ? calculateTestPlatformBreakdown(testData) : {};
            }

            // Generate and show tooltip
            const tooltipContent = generateTooltipContent(platformBreakdown, tooltipType);
            if (tooltipContent) {
                showTooltip(element, tooltipContent);
            }
        }

        // Handle tooltip mouse leave event
        function handleTooltipMouseLeave(event) {
            hideTooltip();
        }

        // Find folder node by path
        function findFolderNode(node, targetPath) {
            if (node.path === targetPath) {
                return node;
            }

            for (const child of Object.values(node.children)) {
                const found = findFolderNode(child, targetPath);
                if (found) return found;
            }

            return null;
        }

        // Show tooltip
        function showTooltip(element, content) {
            // Remove any existing tooltip
            hideTooltip();

            const tooltip = document.createElement('div');
            tooltip.className = 'dynamic-tooltip';
            tooltip.innerHTML = content;

            document.body.appendChild(tooltip);

            // Position tooltip near the element
            const rect = element.getBoundingClientRect();
            const tooltipRect = tooltip.getBoundingClientRect();

            // Account for scroll position
            const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
            const scrollTop = window.pageYOffset || document.documentElement.scrollTop;

            let left = rect.left + scrollLeft + (rect.width / 2) - (tooltipRect.width / 2);
            let top = rect.top + scrollTop - tooltipRect.height - 8;

            // Adjust if tooltip would go off screen (using viewport coordinates)
            if (left - scrollLeft < 8) left = scrollLeft + 8;
            if (left - scrollLeft + tooltipRect.width > window.innerWidth - 8) {
                left = scrollLeft + window.innerWidth - tooltipRect.width - 8;
            }
            if (top - scrollTop < 8) {
                top = rect.bottom + scrollTop + 8;
            }

            tooltip.style.left = left + 'px';
            tooltip.style.top = top + 'px';
        }

        // Hide tooltip
        function hideTooltip() {
            const existing = document.querySelector('.dynamic-tooltip');
            if (existing) {
                existing.remove();
            }
        }

        // Toggle folder expansion
        function toggleFolder(row) {
            const path = row.dataset.path;

            // Save scroll position before DOM changes
            const scrollTop = window.pageYOffset || document.documentElement.scrollTop;

            if (expandedRows.has(path)) {
                expandedRows.delete(path);
            } else {
                expandedRows.add(path);
            }

            changeView();

            // Restore scroll position after DOM rebuild
            window.scrollTo(0, scrollTop);
        }

        // Toggle test chart
        function toggleTestChart(row) {
            const path = row.dataset.path;

            // Save scroll position before DOM changes
            const scrollTop = window.pageYOffset || document.documentElement.scrollTop;

            if (chartRows.has(path)) {
                chartRows.delete(path);
            } else {
                chartRows.add(path);
            }

            // Check if we're in list view
            const listViewCheckbox = document.getElementById('list-view');
            if (listViewCheckbox && listViewCheckbox.checked) {
                // In list view, toggle chart without full re-render
                toggleListViewChart(row, path);
            } else {
                // In tree view, do full re-render
                changeView();

                // Restore scroll position after DOM rebuild
                window.scrollTo(0, scrollTop);
            }
        }

        // Toggle chart in list view without full re-render
        function toggleListViewChart(row, path) {
            let existingChartRow = row.nextElementSibling;
            if (existingChartRow && existingChartRow.classList.contains('chart-expansion')) {
                // Remove existing chart
                existingChartRow.remove();
            } else {
                // Add new chart using the same structure as tree view
                row.insertAdjacentHTML('afterend', generateChartHtml(path));

                // Render the chart
                renderChart(path);
            }
        }

        // Render scatter plots for a test
        function renderChart(testPath) {
            const testData = aggregatedData[testPath];
            if (!testData) return;

            // Closure for plotly click handler - same function instance for both charts
            const plotlyClickHandler = function(data) {
                if (data.points.length > 0) {
                    const point = data.points[0];
                    const { taskIdString, jobName } = point.customdata;
                    const [taskId, retryId] = taskIdString.split('.');
                    const profileUrl = `https://firefox-ci-tc.services.mozilla.com/api/queue/v1/task/${taskId}/runs/${retryId}/artifacts/public/test_info/profile_resource-usage.json`;
                    const profileName = `${jobName} (${taskIdString})`;
                    const testName = testPath.split('/').pop();
                    const profilerUrl = `https://profiler.firefox.com/from-url/${encodeURIComponent(profileUrl)}?profileName=${encodeURIComponent(profileName)}&markerSearch=${encodeURIComponent(testName)}`;
                    window.open(profilerUrl, '_blank');
                }
            };

            const chartIdBase = testPath.replace(/[\/\.]/g, '-');
            const chartId = `chart-${chartIdBase}`;
            const timeoutChartId = `chart-timeout-${chartIdBase}`;
            const chartElement = document.getElementById(chartId);
            const timeoutChartElement = document.getElementById(timeoutChartId);
            if (!chartElement) return;

            // Platform colors (matching builds.html but with different Android color)
            const platformColors = {
                'android': '#8e44ad',       // Purple (instead of green to avoid "passing" implication)
                'linux': '#1f77b4',         // Blue
                'windows': '#ff7f0e',       // Orange
                'mac': '#9467bd',           // Purple
                'unknown': '#7f7f7f'        // Gray
            };

            const failureColor = '#d62728';  // Red for failures
            const timeoutColor = '#ff9800';  // Orange for timeouts

            // Prepare data for scatter plots
            const traces = {};
            const timeoutTraces = {};

            // Use lazy run creation for charts only
            const runs = getTestRuns(testPath);
            let hasTimeouts = false;

            runs.forEach((run, index) => {
                // Skip runs that are marked as skips
                if (run.isSkip) return;

                const platform = extractPlatform(run.jobName) || 'unknown';

                if (run.isTimeout) {
                    // Handle timeouts separately
                    hasTimeouts = true;
                    const traceKey = platform;

                    if (!timeoutTraces[traceKey]) {
                        timeoutTraces[traceKey] = {
                            x: [],
                            y: [],
                            mode: 'markers',
                            type: 'scatter',
                            name: `${platform} (timeout)`,
                            marker: {
                                color: platformColors[platform],
                                size: 8,
                                opacity: 0.7
                            },
                            customdata: [],
                            hovertemplate: '<b>%{customdata.jobName}</b><br>' +
                                           'Repository: %{customdata.repository}<br>' +
                                           'Status: TIMEOUT<br>' +
                                           'Duration: %{customdata.durationStr}<br>' +
                                           'Date: %{customdata.dateStr}<br>' +
                                           '<i>Click to view profile</i><br>' +
                                           '<extra></extra>'
                        };
                    }

                    timeoutTraces[traceKey].x.push(new Date(run.timestamp));
                    timeoutTraces[traceKey].y.push(run.duration / 1000); // Convert to seconds
                    timeoutTraces[traceKey].customdata.push({
                        repository: run.repository,
                        taskIdString: run.taskIdString,
                        jobName: run.jobName,
                        status: 'TIMEOUT',
                        durationStr: formatDuration(run.duration),
                        timestamp: run.timestamp,
                        dateStr: new Date(run.timestamp).toLocaleString()
                    });
                } else {
                    // Handle regular runs and failures
                    const isFail = run.isFail;
                    const traceKey = `${platform}-${isFail ? 'fail' : 'pass'}`;

                    if (!traces[traceKey]) {
                        const color = isFail ? failureColor : platformColors[platform];
                        const displayName = isFail ? `${platform} (failures)` : platform;

                        traces[traceKey] = {
                            x: [],
                            y: [],
                            mode: 'markers',
                            type: 'scatter',
                            name: displayName,
                            marker: {
                                color: color,
                                size: 8,
                                opacity: 0.7
                            },
                            customdata: [],
                            hovertemplate: '<b>%{customdata.jobName}</b><br>' +
                                           'Repository: %{customdata.repository}<br>' +
                                           'Status: %{customdata.status}<br>' +
                                           'Duration: %{customdata.durationStr}<br>' +
                                           'Date: %{customdata.dateStr}<br>' +
                                           '<i>Click to view profile</i><br>' +
                                           '<extra></extra>'
                        };
                    }

                    traces[traceKey].x.push(new Date(run.timestamp));
                    traces[traceKey].y.push(run.duration / 1000); // Convert to seconds
                    traces[traceKey].customdata.push({
                        repository: run.repository,
                        taskIdString: run.taskIdString,
                        jobName: run.jobName,
                        status: run.status || 'UNKNOWN',
                        durationStr: formatDuration(run.duration),
                        timestamp: run.timestamp,
                        dateStr: new Date(run.timestamp).toLocaleString()
                    });
                }
            });

            // Render main chart (without timeouts)
            const layout = {
                title: `${testPath} - Run Times`,
                xaxis: {
                    title: 'Date',
                    type: 'date',
                    tickformat: '%Y-%m-%d'
                },
                yaxis: {
                    title: 'Duration (seconds)',
                    rangemode: 'tozero'
                },
                hovermode: 'closest',
                height: 400
            };

            const config = {
                responsive: true,
                displayModeBar: true
            };

            Plotly.newPlot(chartId, Object.values(traces), layout, config);

            // Add click handler to open profiles
            document.getElementById(chartId).on('plotly_click', plotlyClickHandler);

            // Render timeout chart only if there are timeouts
            if (hasTimeouts && timeoutChartElement) {
                const timeoutLayout = {
                    title: `${testPath} - Timeouts`,
                    xaxis: {
                        title: 'Date',
                        type: 'date',
                        tickformat: '%Y-%m-%d'
                    },
                    yaxis: {
                        title: 'Duration (seconds)'
                        // Remove rangemode: 'tozero' to allow auto-scaling
                    },
                    hovermode: 'closest',
                    height: 300
                };

                Plotly.newPlot(timeoutChartId, Object.values(timeoutTraces), timeoutLayout, config);

                // Add click handler to open profiles for timeouts
                document.getElementById(timeoutChartId).on('plotly_click', plotlyClickHandler);
            }
        }

        // Auto-expand folders that contain matching tests for a search term
        function autoExpandForSearch(searchTerm) {
            const lowerSearchTerm = searchTerm.toLowerCase();

            // Function to recursively expand folders with matches
            function expandMatchingFolders(node, currentPath = '') {
                // Check tests in this node
                for (const testName of Object.keys(node.tests)) {
                    const fullPath = currentPath ? `${currentPath}/${testName}` : testName;
                    if (fullPath.toLowerCase().includes(lowerSearchTerm)) {
                        // Expand all parent folders of this test
                        const parts = fullPath.split('/');
                        for (let i = 1; i < parts.length; i++) {
                            expandedRows.add(parts.slice(0, i).join('/'));
                        }
                    }
                }

                // Check child folders
                for (const childName of Object.keys(node.children)) {
                    const childPath = currentPath ? `${currentPath}/${childName}` : childName;
                    expandMatchingFolders(node.children[childName], childPath);
                }
            }

            if (treeData) {
                expandMatchingFolders(treeData);
            }
        }

        // Change view based on checkbox
        function changeView() {
            const listViewCheckbox = document.getElementById('list-view');
            const isListView = listViewCheckbox.checked;

            // Update URL hash to reflect view change
            updateUrlHash();

            if (isListView) {
                renderListView();
            } else {
                renderTree();
            }
        }

        // Apply filtering to current view (tree or list)
        function applyFiltering() {
            const listViewCheckbox = document.getElementById('list-view');
            const isListView = listViewCheckbox.checked;
            const searchTerm = document.getElementById('search-box').value.toLowerCase().trim();

            if (isListView) {
                // List view filtering - re-render with filtered data
                renderListView();
            } else {
                // Tree view filtering
                if (!searchTerm) {
                    // Clear search - collapse all
                    expandedRows.clear();
                    renderTree();
                    return;
                }

                // Auto-expand folders that contain matching tests
                expandedRows.clear();
                autoExpandForSearch(searchTerm);
                renderTree();
            }
        }

        // Load data from cache
        async function loadData() {
            setStatusText('Loading data...');
            hideError();

            try {
                const dateToLoad = document.getElementById('date-select').value;

                if (!dateToLoad) {
                    throw new Error('No date selected');
                }

                const file = `xpcshell-${dateToLoad}.json`;
                const response = await fetch(`./xpcshell-data/${file}`);

                if (!response.ok) {
                    throw new Error('No data available');
                }

                currentData = await response.json();

                // Process raw data to create test entries and tree structure
                aggregatedData = createTestEntries();
                treeData = buildTreeStructure(aggregatedData);

                // Update date selector and show job count
                if (currentData.metadata && currentData.metadata.date) {
                    updateDateSelector(currentData.metadata.date);
                    const jobCount = currentData.metadata.jobCount || 0;
                    setStatusText(`${jobCount.toLocaleString()} test jobs`);
                }

                changeView();
            } catch (error) {
                showError(`Error loading data: ${error.message}`, true);
            } finally {
                // Status text will show either job count (on success) or remain as loading (on error)
            }
        }

        // Update date selector
        function updateDateSelector(currentDate) {
            const select = document.getElementById('date-select');

            // Add current date if not already present
            const existingOption = Array.from(select.options).find(opt => opt.value === currentDate);
            if (!existingOption) {
                const option = document.createElement('option');
                option.value = currentDate;
                option.text = currentDate;
                option.selected = true;
                select.insertBefore(option, select.options[0]); // Insert at the beginning
            }
        }

        // Helper function to update clear button visibility (defined globally so it's accessible everywhere)
        function updateClearButton() {
            const searchBox = document.getElementById('search-box');
            const clearButton = document.getElementById('search-clear');
            clearButton.style.display = searchBox.value.trim() ? 'flex' : 'none';
        }

        // Populate date selector with available dates from index
        async function populateDateSelector() {
            const select = document.getElementById('date-select');

            try {
                const response = await fetch('./xpcshell-data/index.json');
                if (response.ok) {
                    const index = await response.json();

                    // Clear all existing options
                    select.innerHTML = '';

                    // Add all available dates
                    if (index.dates && index.dates.length > 0) {
                        index.dates.forEach((date, dateIndex) => {
                            const option = document.createElement('option');
                            option.value = date;
                            option.text = date;
                            option.selected = dateIndex === 0; // Select first (most recent) date
                            select.appendChild(option);
                        });

                        // After populating dropdown, restore state from URL hash
                        const hash = window.location.hash.slice(1);
                        if (hash) {
                            const params = new URLSearchParams(hash);

                            // Restore date selection
                            const urlDate = params.get('date');
                            if (urlDate && index.dates.includes(urlDate)) {
                                select.value = urlDate;
                            }

                            // Restore search filter
                            const search = params.get('q');
                            if (search) {
                                document.getElementById('search-box').value = search;
                                updateClearButton();
                            }

                            // Restore list view state
                            const view = params.get('view');
                            if (view === 'list') {
                                document.getElementById('list-view').checked = true;
                            }
                        }
                    } else {
                        // No dates available
                        showError('No data available. Please run: node fetch-xpcshell-data.js', true);
                    }
                } else {
                    // Index file doesn't exist
                    showError('No data available. Please run: node fetch-xpcshell-data.js to fetch data.', true);
                }
            } catch (e) {
                console.warn('Could not load date index:', e);
                showError('Error loading data index. Please ensure xpcshell-data/index.json exists.', true);
            }
        }

        // Fetch new data by running the Node.js script
        async function fetchNewData() {
            showError('To fetch new data, run: node fetch-xpcshell-data.js');
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', async () => {
            // Get references to search elements
            const searchBox = document.getElementById('search-box');
            const clearButton = document.getElementById('search-clear');

            // Populate date selector first
            await populateDateSelector();

            // Then load data only if we have dates
            if (document.getElementById('date-select').value) {
                loadData();
            }

            // Set up search box with debouncing
            let filterTimeout;

            searchBox.addEventListener('input', function(e) {
                // Update clear button visibility
                updateClearButton();

                // Clear previous timeout
                clearTimeout(filterTimeout);

                // Debounce both the filtering operation and hash update together
                filterTimeout = setTimeout(() => {
                    // Update hash first (with current search box value)
                    if (!isNavigating) {
                        updateUrlHash();
                    }
                    // Then do the expensive filtering
                    originalFilterTree();
                }, 300); // 300ms delay
            });

            // Clear button functionality
            clearButton.addEventListener('click', function() {
                searchBox.value = '';
                updateClearButton();
                clearTimeout(filterTimeout);
                applyFiltering(); // Clear filter immediately
                searchBox.focus(); // Keep focus on search box
            });

            function loadFromUrlHash() {
                const hash = window.location.hash.slice(1); // Remove #
                const params = new URLSearchParams(hash);

                // Restore date selection (or clear if not in hash)
                const date = params.get('date');
                document.getElementById('date-select').value = date || '';

                // Restore search filter (or clear if not in hash)
                const search = params.get('q');
                document.getElementById('search-box').value = search || '';
                updateClearButton();

                // Restore view selection (or clear if not in hash)
                const view = params.get('view');
                document.getElementById('list-view').checked = view === 'list';
            }

            // URL hash will be loaded after the date index is fetched

            // Update hash when date changes (modify existing loadData function)
            const originalOnChange = document.getElementById('date-select').onchange;
            document.getElementById('date-select').onchange = function() {
                updateUrlHash();
                if (originalOnChange) originalOnChange.call(this);
            };

            // Flag to prevent hash updates during navigation
            let isNavigating = false;

            // Store reference to filtering function (no wrapper needed since we handle hash in input handler)
            const originalFilterTree = applyFiltering;

            // Handle browser back/forward buttons
            window.addEventListener('hashchange', function() {
                isNavigating = true;
                loadFromUrlHash();

                if (document.getElementById('date-select').value) {
                    loadData(); // This will also call filtering after loading data
                } else {
                    applyFiltering(); // Update view with current filter state
                }

                isNavigating = false;
            });
        });
    </script>
</body>
</html>
