<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>XPCShell Test Timings</title>
    <script src="fetch-utils.js"></script>
    <script defer src="shared.js"></script>
    <link rel="stylesheet" href="shared.css">
    <style>
        .tree-table {
            width: 100%;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .tree-row {
            border-bottom: 1px solid #eee;
            cursor: pointer;
            transition: background-color 0.2s;
            display: flex;
            align-items: center;
            padding: 4px 10px;
            min-height: 28px; /* Ensure consistent height even when empty */
        }

        .tree-row:hover {
            background-color: #f5f5f5;
        }

        .tree-row.expanded {
            background-color: #f0f8ff;
        }

        .tree-name {
            flex: 1;
            font-family: monospace;
            font-size: 13px;
        }

        .tree-stats {
            display: flex;
            gap: 30px;
            font-size: 13px;
        }

        .stat-item {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            text-align: right;
            min-width: 60px;
        }

        .stat-label {
            color: #666;
            font-size: 11px;
            text-transform: uppercase;
        }

        .stat-value {
            font-weight: bold;
            color: #333;
        }

        .stat-value.fail {
            color: #d00;
        }

        .stat-value.skip, .stat-value.zero {
            color: #888;
        }

        .stat-value.timeout {
            color: #f60;
        }

        .folder-icon, .test-icon {
            margin-right: 5px;
        }

        .folder-icon::before {
            content: "üìÅ ";
        }

        .folder-icon.expanded::before {
            content: "üìÇ ";
        }

        .test-icon::before {
            content: "üìÑ ";
        }

        .tree-indent {
            display: inline-block;
            width: 20px;
        }

        .chart-expansion {
            padding: 20px;
            background: #f9f9f9;
            border-top: 1px solid #ddd;
        }

        .controls {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 20px;
            gap: 20px;
        }

        .search-container {
            position: relative;
            display: inline-block;
        }

        .search-box {
            padding: 8px 30px 8px 12px;
            width: 300px;
            box-sizing: border-box;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            flex-shrink: 0;
        }

        .search-clear {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            font-size: 16px;
            color: #999;
            padding: 0;
            width: 20px;
            height: 20px;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .search-clear:hover {
            color: #666;
        }

        .date-selector {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-shrink: 0;
        }

        .status-text {
            font-size: 14px;
            color: #666;
            margin: 0;
            padding: 0;
            vertical-align: baseline;
        }

        .no-data {
            padding: 40px;
            text-align: center;
            color: #666;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .sort-header {
            background: #f8f9fa;
            border-bottom: 2px solid #ddd;
            padding: 0 10px;
            display: flex;
            align-items: center;
            font-weight: bold;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .sort-header .tree-stats {
            gap: 30px; /* Match the gap from regular tree-stats */
        }

        .sort-header .tree-name {
            color: #666;
        }

        .sort-button {
            background: none;
            border: none;
            cursor: pointer;
            padding: 10px;
            margin: 0 -10px;
            font-size: 11px;
            text-transform: uppercase;
            color: #666;
            border-radius: 3px;
            transition: background-color 0.2s;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            text-align: right;
            width: 100%;
            white-space: nowrap;
        }

        .sort-button:hover {
            background-color: #e9ecef;
        }

        .sort-button.active {
            color: #007bff;
            background-color: #e7f3ff;
        }

        .sort-arrow {
            font-size: 10px;
            margin-right: 2px;
            width: 8px;
            display: inline-block;
            text-align: left;
        }

        .tooltip {
            position: relative;
            cursor: help;
        }

        .tooltip .tooltiptext {
            visibility: hidden;
            width: 200px;
            background-color: #2a2a2a;
            color: white;
            text-align: left;
            border-radius: 6px;
            padding: 8px;
            position: absolute;
            z-index: 1000;
            bottom: 125%;
            right: 0;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 12px;
            line-height: 1.4;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .tooltip .tooltiptext::after {
            content: "";
            position: absolute;
            top: 100%;
            right: 20px;
            border-width: 5px;
            border-style: solid;
            border-color: #2a2a2a transparent transparent transparent;
        }

        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }

        .tooltip-platform {
            display: flex;
            justify-content: space-between;
            margin: 2px 0;
        }

        .tooltip-platform-name {
            font-weight: bold;
        }

        .total-row {
            background-color: #f8f9fa;
            border-bottom: 2px solid #ddd;
            font-weight: bold;
        }

        .total-row:hover {
            background-color: #f8f9fa;
        }

        .total-row .tree-name {
            color: #495057;
        }

        .lazy-row .loading {
            color: #999;
            font-style: italic;
        }

        .dynamic-tooltip {
            position: absolute;
            background: #333;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            white-space: nowrap;
            z-index: 1000;
            pointer-events: none;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .action-button {
            background: none;
            border: none;
            cursor: pointer;
            padding: 2px 4px;
            margin-left: 6px;
            font-size: 11px;
            color: #666;
            border-radius: 3px;
            transition: background-color 0.2s;
            opacity: 0;
            vertical-align: middle;
            text-decoration: none;
            display: inline-block;
        }

        .tree-row:hover .action-button,
        .folder-row:hover .action-button {
            opacity: 1;
        }

        .action-button:hover {
            background-color: #e9ecef;
            color: #333;
        }

        .action-button:active {
            background-color: #007bff;
            color: white;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>XPCShell Test Timings</h1>

        <div class="controls">
            <div class="date-selector">
                <label for="date-select">Select Date: </label>
                <select id="date-select" onchange="loadData()">
                </select>
                <span id="status-text" class="status-text">Loading data...</span>
            </div>
            <div class="date-selector">
                <label>Show as</label>
                <label id="components-view-label">
                    <input id="view-components" type="radio" name="view-mode" value="components" onchange="changeView()" checked>
                    bugzilla components
                </label>
                <label>
                    <input id="view-tree" type="radio" name="view-mode" value="tree" onchange="changeView()">
                    source tree
                </label>
                <label>
                    <input id="view-list" type="radio" name="view-mode" value="list" onchange="changeView()">
                    list
                </label>
            </div>
            <div class="search-container">
                <input type="text" class="search-box" id="search-box" placeholder="Search for test paths...">
                <button class="search-clear" id="search-clear" title="Clear search">√ó</button>
            </div>
        </div>
        <div id="error" class="error" style="display: none;"></div>

        <div id="tree-container" style="display: none;">
            <div class="tree-table" id="tree-table"></div>
        </div>

        <div id="no-data" class="no-data" style="display: none;">
            No data available. Click "Fetch New Data" to fetch xpcshell test data.
        </div>
    </div>

    <script>
        let currentData = null;
        let aggregatedData = null;
        let treeData = null;
        let expandedRows = new Set();
        let chartRows = new Set();
        let sortField = 'failCount';
        let sortDirection = 'desc'; // Start with descending for failure count (most failing first)
        let listObserver = null; // Intersection Observer for list view lazy loading

        // Format duration in milliseconds to human readable
        function formatDurationMs(ms, hasData = true) {
            if (!hasData || ms === 0) {
                return '‚Äî';  // Em dash for no data
            }
            if (ms < 1000) {
                return `${Math.round(ms)}ms`;
            } else if (ms < 60000) {
                return `${(ms / 1000).toFixed(1)}s`;
            } else if (ms < 3600000) {  // Less than 1 hour
                const minutes = Math.floor(ms / 60000);
                const seconds = Math.floor((ms % 60000) / 1000);
                if (seconds === 0) {
                    return `${minutes}m`;
                }
                return `${minutes}m ${seconds}s`;
            } else if (ms < 86400000) {  // Less than 1 day
                const hours = Math.floor(ms / 3600000);
                const minutes = Math.floor((ms % 3600000) / 60000);
                if (minutes === 0) {
                    return `${hours}h`;
                }
                return `${hours}h ${minutes}m`;
            } else {  // Days
                const days = Math.floor(ms / 86400000);
                const hours = Math.floor((ms % 86400000) / 3600000);
                if (hours === 0) {
                    return `${days}d`;
                }
                return `${days}d ${hours}h`;
            }
        }


        // Format numbers with thousand separators
        function formatNumber(num) {
            return num.toLocaleString();
        }

        // Escape HTML to prevent XSS
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Calculate pass percentage with consistent precision
        function calculatePassPercentage(passCount, runCount) {
            if (runCount === 0) return 0;
            return Math.round((passCount / runCount) * 10000) / 100;
        }

        // Generate individual stat item HTML
        function generateStatItem(label, value, valueCssClass = '', containerClass = '', title = '', extraAttrs = '') {
            const titleAttr = title ? ` title="${title}"` : '';
            const containerClassAttr = containerClass ? ` class="stat-item ${containerClass}"` : ' class="stat-item"';
            const valueClassAttr = valueCssClass ? ` class="stat-value ${valueCssClass}"` : ' class="stat-value"';
            return `<div${containerClassAttr}${titleAttr}${extraAttrs}><span class="stat-label">${label}</span><span${valueClassAttr}>${value}</span></div>`;
        }

        // Generate stats HTML for a test (shared between tree and list views)
        function generateStatsHtml(stats, testPath, hasRuns) {
            // Use avgDuration if provided, otherwise calculate it
            const avgDuration = stats.avgDuration !== undefined ? stats.avgDuration :
                (stats.passCount > 0 ? stats.totalDuration / stats.passCount : 0);

            let html = '';
            html += generateStatItem('Min', formatDurationMs(stats.min, hasRuns), '', stats.min > 0 ? 'lazy-tooltip' : '', '', stats.min > 0 ? ` data-test-path="${testPath}" data-tooltip-type="min"` : '');
            html += generateStatItem('Avg', formatDurationMs(avgDuration, hasRuns), '', avgDuration > 0 ? 'lazy-tooltip' : '', '', avgDuration > 0 ? ` data-test-path="${testPath}" data-tooltip-type="avg"` : '');
            html += generateStatItem('Max', formatDurationMs(stats.max, hasRuns), '', stats.max > 0 ? 'lazy-tooltip' : '', '', stats.max > 0 ? ` data-test-path="${testPath}" data-tooltip-type="max"` : '');
            html += generateStatItem('Runs', formatNumber(stats.runCount), stats.runCount === 0 ? 'fail' : '', '', `Total duration of passing runs: ${formatDurationMs(stats.totalDuration, hasRuns)}`);

            const passPercentageClass = stats.passPercentage < 100 && stats.runCount > 0 ? (stats.passPercentage === 0 ? 'fail' : '') : 'zero';
            html += generateStatItem('Pass %', `${stats.passPercentage}%`, passPercentageClass);

            // Parallel failure percentage (only show if we have data)
            const parallelTotalRuns = (stats.parallelFailCount || 0) + (stats.parallelTimeoutCount || 0) + (stats.parallelPassCount || 0);
            const parallelProblematicCount = (stats.parallelFailCount || 0) + (stats.parallelTimeoutCount || 0);
            const hasParallelData = parallelTotalRuns > 0;
            html += generateStatItem('Skips', formatNumber(stats.skipCount), 'skip', stats.skipCount > 0 ? 'lazy-tooltip' : '', '', stats.skipCount > 0 ? ` data-test-path="${testPath}" data-tooltip-type="skips"` : '');

            const failClass = stats.failCount > 0 ? 'fail' : 'zero';
            html += generateStatItem('Failures', formatNumber(stats.failCount), failClass, stats.failCount > 0 ? 'lazy-tooltip' : '', '', stats.failCount > 0 ? ` data-test-path="${testPath}" data-tooltip-type="failures"` : '');

            const timeoutClass = stats.timeoutCount > 0 ? 'timeout' : 'zero';
            html += generateStatItem('Timeouts', formatNumber(stats.timeoutCount), timeoutClass, stats.timeoutCount > 0 ? 'lazy-tooltip' : '', '', stats.timeoutCount > 0 ? ` data-test-path="${testPath}" data-tooltip-type="timeouts"` : '');

            return html;
        }

        // Generate chart HTML structure (shared between tree and list views)
        function generateChartHtml(testPath) {
            const chartIdBase = testPath.replace(/[\/\.]/g, '-');
            return `
                <div class="chart-expansion">
                    <div id="chart-${chartIdBase}"></div>
                    <div id="chart-timeout-${chartIdBase}"></div>
                    <div id="chart-crash-${chartIdBase}"></div>
                </div>`;
        }

        // Generate copy button for test paths
        function generateCopyButton(testPath) {
            return `<button class="action-button" onclick="copyTestName('${testPath}'); event.stopPropagation();" title="Copy test path">üìã</button>`;
        }

        // Generate Searchfox button for test paths
        function generateSearchfoxButton(testPath) {
            const searchfoxUrl = `https://searchfox.org/mozilla-central/source/${testPath}`;
            return `<a href="${searchfoxUrl}" class="action-button" target="_blank" onclick="event.stopPropagation();" title="Open in Searchfox">üîç</a>`;
        }

        // Generate both copy and Searchfox buttons for test paths
        function generateTestButtons(testPath) {
            return generateCopyButton(testPath) + generateSearchfoxButton(testPath);
        }

        // Generate Searchfox button for folder paths
        function generateFolderButtons(folderPath) {
            const searchfoxUrl = `https://searchfox.org/mozilla-central/source/${folderPath}`;
            return `<a href="${searchfoxUrl}" class="action-button" target="_blank" onclick="event.stopPropagation();" title="Open folder in Searchfox">üîç</a>`;
        }

        // Error display management (shared across all error scenarios)
        function showError(message, showNoData = false) {
            const errorElement = document.getElementById('error');
            errorElement.style.display = 'block';
            errorElement.textContent = message;

            if (showNoData) {
                document.getElementById('no-data').style.display = 'block';
            }
        }

        function hideError() {
            document.getElementById('error').style.display = 'none';
            document.getElementById('no-data').style.display = 'none';
        }

        // Status text management (shared for loading states)
        function setStatusText(text) {
            document.getElementById('status-text').textContent = text;
        }

        // URL hash management
        // Helper to check if component data is available
        function hasComponentData() {
            return currentData && currentData.testInfo && currentData.testInfo.componentIds && currentData.tables && currentData.tables.components;
        }

        // Helper to get current view mode
        function getCurrentView() {
            if (document.getElementById('view-components').checked) {
                // If components is selected but no component data, fall back to tree
                return hasComponentData() ? 'components' : 'tree';
            } else if (document.getElementById('view-tree').checked) {
                return 'tree';
            } else if (document.getElementById('view-list').checked) {
                return 'list';
            }
            // Default: components if available, otherwise tree
            return hasComponentData() ? 'components' : 'tree';
        }

        function updateUrlHash() {
            const date = document.getElementById('date-select').value;
            const search = document.getElementById('search-box').value.trim();
            const view = getCurrentView();

            const params = new URLSearchParams();
            if (date) params.set('date', date);
            if (search) params.set('q', search);
            // Only add view to URL if not the default
            if (view !== 'components') params.set('view', view);

            const hash = params.toString();
            if (hash) {
                window.location.hash = hash;
            } else {
                // Preserve search parameters when clearing hash
                const url = window.location.pathname + window.location.search;
                history.replaceState(null, '', url);
            }
        }

        // Create test data entries with only testIds - everything computed from global currentData
        function createTestEntries() {
            const testEntries = {};

            if (!currentData.testRuns || !currentData.tables || !currentData.taskInfo || !currentData.testInfo) {
                return testEntries;
            }

            // Create minimal entries for each test with only testId
            for (let testId = 0; testId < currentData.testRuns.length; testId++) {
                const testGroup = currentData.testRuns[testId];
                if (!testGroup) continue;

                const testPath = currentData.tables.testPaths[currentData.testInfo.testPathIds[testId]];
                const testName = currentData.tables.testNames[currentData.testInfo.testNameIds[testId]];
                const fullPath = testPath ? `${testPath}/${testName}` : testName;

                // Get component if available
                const componentId = currentData.testInfo.componentIds ? currentData.testInfo.componentIds[testId] : null;
                const component = (componentId !== null && currentData.tables.components) ? currentData.tables.components[componentId] : null;

                testEntries[fullPath] = {
                    testId: testId,
                    component: component
                };
            }

            return testEntries;
        }

        // Compute statistics for a single test from global currentData
        function computeTestStats(testId) {
            const testGroup = currentData.testRuns[testId];

            if (!testGroup) {
                return {
                    runCount: 0,
                    skipCount: 0,
                    passCount: 0,
                    failCount: 0,
                    timeoutCount: 0,
                    passPercentage: 0,
                    max: 0,
                    min: 0,
                    avg: 0
                };
            }

            let skipCount = 0;
            let timeoutCount = 0;
            let failCount = 0;
            let passCount = 0;
            let maxDuration = 0;
            let minDuration = Infinity;
            let totalDuration = 0;
            let parallelFailCount = 0;
            let parallelPassCount = 0;
            let parallelTimeoutCount = 0;
            let sequentialPassCount = 0;
            let sequentialFailCount = 0;
            let sequentialTimeoutCount = 0;

            // Process each status group within this test
            for (let statusId = 0; statusId < testGroup.length; statusId++) {
                const statusGroup = testGroup[statusId];
                if (!statusGroup) continue;

                const status = currentData.tables.statuses[statusId];
                const runCount = statusGroup.taskIdIds.length;

                const isSkip = status === 'SKIP';
                const isTimeout = status && status.startsWith('TIMEOUT');
                const isFail = status && !status.startsWith('PASS') && !status.startsWith('TIMEOUT') && !['SKIP', 'CRASH', 'EXPECTED-FAIL'].includes(status);

                // Add counts for this status group
                if (isSkip) {
                    // Only count as skip if the message doesn't start with "run-if"
                    // (run-if indicates platform-specific tests, not actual skips due to broken tests)
                    if (statusGroup.messageIds) {
                        for (const messageId of statusGroup.messageIds) {
                            const message = messageId !== null ? currentData.tables.messages[messageId] : null;
                            // Count as skip if there's no message or if it doesn't start with run-if
                            if (!message || !message.startsWith('run-if')) {
                                skipCount++;
                            }
                            // run-if skips are not counted (platform-specific tests that are irrelevant on this platform)
                        }
                    } else {
                        // If there are no message IDs, count all as skips
                        skipCount += runCount;
                    }
                } else if (status === 'TIMEOUT-PARALLEL') {
                    timeoutCount += runCount;
                    parallelTimeoutCount += runCount;
                } else if (status === 'TIMEOUT-SEQUENTIAL') {
                    timeoutCount += runCount;
                    sequentialTimeoutCount += runCount;
                } else if (isTimeout) {
                    // Old TIMEOUT without parallel/sequential designation
                    timeoutCount += runCount;
                } else if (status === 'UNKNOWN') {
                    // Split UNKNOWN by duration: skips, timeouts, or passes
                    for (const duration of statusGroup.durations) {
                        if (duration < 100) {
                            skipCount++;
                        } else if (duration > 300000) {
                            timeoutCount++;
                        } else {
                            passCount++;
                            totalDuration += duration;
                            if (duration > maxDuration) {
                                maxDuration = duration;
                            }
                            if (duration < minDuration) {
                                minDuration = duration;
                            }
                        }
                    }
                } else if (status === 'FAIL-PARALLEL') {
                    failCount += runCount;
                    parallelFailCount += runCount;
                } else if (status === 'FAIL-SEQUENTIAL') {
                    failCount += runCount;
                    sequentialFailCount += runCount;
                } else if (status === 'PASS-PARALLEL') {
                    passCount += runCount;
                    parallelPassCount += runCount;
                    for (const duration of statusGroup.durations) {
                        totalDuration += duration;
                        if (duration > maxDuration) {
                            maxDuration = duration;
                        }
                        if (duration < minDuration) {
                            minDuration = duration;
                        }
                    }
                } else if (status === 'PASS-SEQUENTIAL') {
                    passCount += runCount;
                    sequentialPassCount += runCount;
                    for (const duration of statusGroup.durations) {
                        totalDuration += duration;
                        if (duration > maxDuration) {
                            maxDuration = duration;
                        }
                        if (duration < minDuration) {
                            minDuration = duration;
                        }
                    }
                } else if (isFail) {
                    failCount += runCount;
                } else {
                    // PASS or EXPECTED-FAIL (or old PASS without parallel/sequential designation)
                    passCount += runCount;
                    for (const duration of statusGroup.durations) {
                        totalDuration += duration;
                        if (duration > maxDuration) {
                            maxDuration = duration;
                        }
                        if (duration < minDuration) {
                            minDuration = duration;
                        }
                    }
                }
            }

            const runCount = skipCount + timeoutCount + failCount + passCount - skipCount; // Total minus skips

            // Calculate parallel failure rate correctly:
            // This is the percentage of parallel runs that failed or timed out
            const parallelTotalRuns = parallelFailCount + parallelTimeoutCount + parallelPassCount;
            const parallelProblematicCount = parallelFailCount + parallelTimeoutCount;
            const parallelFailPercentage = parallelTotalRuns > 0
                ? Math.round((parallelProblematicCount * 100) / parallelTotalRuns)
                : 0;

            // Handle case where no durations were found
            const finalMinDuration = minDuration === Infinity ? 0 : minDuration;

            return {
                runCount: runCount,
                skipCount: skipCount,
                passCount: passCount,
                timeoutCount: timeoutCount,
                failCount: failCount,
                parallelFailCount: parallelFailCount,
                parallelTimeoutCount: parallelTimeoutCount,
                parallelPassCount: parallelPassCount,
                sequentialPassCount: sequentialPassCount,
                sequentialFailCount: sequentialFailCount,
                sequentialTimeoutCount: sequentialTimeoutCount,
                parallelFailPercentage: parallelFailPercentage,
                passPercentage: calculatePassPercentage(passCount, runCount),
                max: maxDuration,
                min: finalMinDuration,
                totalDuration: totalDuration
            };
        }

        // Lazy function to get platforms for a test
        function getTestPlatforms(testPath) {
            const testData = aggregatedData[testPath];
            if (!testData) return [];

            if (testData.platforms) {
                return testData.platforms;
            }

            const platforms = new Set();
            const testGroup = currentData.testRuns[testData.testId];

            if (testGroup) {
                // Process each status group to collect platforms
                for (let statusId = 0; statusId < testGroup.length; statusId++) {
                    const statusGroup = testGroup[statusId];
                    if (!statusGroup) continue;

                    for (let i = 0; i < statusGroup.taskIdIds.length; i++) {
                        const taskIdIndex = statusGroup.taskIdIds[i];
                        const jobName = currentData.tables.jobNames[currentData.taskInfo.jobNameIds[taskIdIndex]];
                        platforms.add(extractPlatform(jobName) || 'unknown');
                    }
                }
            }

            // Cache platforms
            testData.platforms = Array.from(platforms);
            return testData.platforms;
        }

        // Lazy function to create run objects only when needed for charts
        function getTestRuns(testPath) {
            const testData = aggregatedData[testPath];
            if (!testData || testData.runs) {
                // Already computed or no data
                return testData?.runs || [];
            }

            const testGroup = currentData.testRuns[testData.testId];
            const runs = [];
            const startTime = (currentData.metadata.startTime || 0) * 1000; // Convert seconds to ms

            if (!testGroup) return runs;

            // Process each status group for this test
            for (let statusId = 0; statusId < testGroup.length; statusId++) {
                const statusGroup = testGroup[statusId];
                if (!statusGroup) continue;

                const status = currentData.tables.statuses[statusId];
                const runCount = statusGroup.taskIdIds.length;

                // Decompress differential timestamps back to absolute values
                const decompressedTimestamps = [];
                if (statusGroup.timestamps.length > 0) {
                    let currentTimestamp = 0;
                    for (let i = 0; i < statusGroup.timestamps.length; i++) {
                        currentTimestamp += statusGroup.timestamps[i];
                        decompressedTimestamps.push(currentTimestamp);
                    }
                }

                for (let i = 0; i < runCount; i++) {
                    const duration = statusGroup.durations[i];
                    const taskIdIndex = statusGroup.taskIdIds[i];
                    const taskIdString = currentData.tables.taskIds[taskIdIndex];
                    const jobName = currentData.tables.jobNames[currentData.taskInfo.jobNameIds[taskIdIndex]];

                    const run = {
                        duration: duration,
                        repository: currentData.tables.repositories[currentData.taskInfo.repositoryIds[taskIdIndex]],
                        jobName: jobName,
                        taskIdString: taskIdString,
                        status: status,
                        timestamp: startTime + (decompressedTimestamps[i] * 1000), // Convert relative seconds to absolute ms
                        isFail: status && !status.startsWith('PASS') && !status.startsWith('TIMEOUT') && !['SKIP', 'CRASH', 'EXPECTED-FAIL'].includes(status),
                        isSkip: status === 'SKIP',
                        isTimeout: (status && status.startsWith('TIMEOUT')) || (status === 'UNKNOWN' && duration > 300000)
                    };

                    // Add crash data for CRASH status
                    if (status === 'CRASH' && statusGroup.crashSignatureIds && statusGroup.minidumps) {
                        const crashSigId = statusGroup.crashSignatureIds[i];
                        run.crashSignature = crashSigId !== null ? currentData.tables.crashSignatures[crashSigId] : null;
                        run.minidump = statusGroup.minidumps[i];
                    }

                    // Add failure message for FAIL* statuses
                    if (status && status.startsWith('FAIL') && statusGroup.messageIds) {
                        const messageId = statusGroup.messageIds[i];
                        run.failureMessage = messageId !== null ? currentData.tables.messages[messageId] : null;
                    }

                    runs.push(run);
                }
            }

            // Cache the runs for future use
            testData.runs = runs;
            return runs;
        }

        // Build tree structure from test entries, computing statistics directly from raw data
        function buildTreeStructure(testEntries) {
            const tree = {
                name: 'root',
                path: '',
                children: {},
                tests: {}
            };

            for (const testPath in testEntries) {
                const parts = testPath.split('/');
                let currentNode = tree;

                // Navigate/create folder structure
                for (let i = 0; i < parts.length - 1; i++) {
                    const folder = parts[i];

                    if (!currentNode.children[folder]) {
                        currentNode.children[folder] = {
                            name: folder,
                            path: parts.slice(0, i + 1).join('/'),
                            children: {},
                            tests: {}
                        };
                    }

                    currentNode = currentNode.children[folder];
                }

                // Compute test statistics from global currentData
                const testData = testEntries[testPath];
                const testStats = computeTestStats(testData.testId);

                // Add computed stats to test data
                testData.stats = testStats;

                // Add test to the final folder
                const testName = parts[parts.length - 1];
                currentNode.tests[testName] = {
                    name: testName,
                    path: testPath,
                    data: testData
                };
            }

            // Note: Folder stats are now computed on-demand by calculateFilteredStats
            return tree;
        }

        // Sort function
        function sortItems(items, isFolder, node) {
            return items.sort((a, b) => {
                let valueA, valueB;

                if (isFolder) {
                    // Compute stats on-demand for sorting
                    const nodeA = (typeof a === 'string') ? node.children[a] : a;
                    const nodeB = (typeof b === 'string') ? node.children[b] : b;
                    const statsA = calculateFilteredStats(nodeA, ''); // No search term = all stats
                    const statsB = calculateFilteredStats(nodeB, ''); // No search term = all stats

                    switch(sortField) {
                        case 'name':
                            valueA = (typeof a === 'string') ? a : a.name || '';
                            valueB = (typeof b === 'string') ? b : b.name || '';
                            return sortDirection === 'asc' ? valueA.localeCompare(valueB) : valueB.localeCompare(valueA);
                        case 'testCount':
                            valueA = statsA.testCount || 0;
                            valueB = statsB.testCount || 0;
                            break;
                        case 'runCount':
                            valueA = statsA.runCount || 0;
                            valueB = statsB.runCount || 0;
                            break;
                        case 'passPercentage':
                            valueA = parseFloat(statsA.passPercentage) || 0;
                            valueB = parseFloat(statsB.passPercentage) || 0;
                            break;
                        case 'skipCount':
                            valueA = statsA.skipCount || 0;
                            valueB = statsB.skipCount || 0;
                            break;
                        case 'failCount':
                            valueA = statsA.failCount || 0;
                            valueB = statsB.failCount || 0;
                            break;
                        case 'timeoutCount':
                            valueA = statsA.timeoutCount || 0;
                            valueB = statsB.timeoutCount || 0;
                            break;
                        default:
                            valueA = parseFloat(statsA.passPercentage) || 0;
                            valueB = parseFloat(statsB.passPercentage) || 0;
                    }
                } else {
                    const statsA = (typeof a === 'string') ? node.tests[a].data.stats : a.data.stats;
                    const statsB = (typeof b === 'string') ? node.tests[b].data.stats : b.data.stats;

                    switch(sortField) {
                        case 'name':
                            valueA = (typeof a === 'string') ? a : a.name || '';
                            valueB = (typeof b === 'string') ? b : b.name || '';
                            return sortDirection === 'asc' ? valueA.localeCompare(valueB) : valueB.localeCompare(valueA);
                        case 'avg':
                            valueA = statsA.passCount > 0 ? statsA.totalDuration / statsA.passCount : 0;
                            valueB = statsB.passCount > 0 ? statsB.totalDuration / statsB.passCount : 0;
                            break;
                        case 'max':
                            valueA = statsA.max || 0;
                            valueB = statsB.max || 0;
                            break;
                        case 'runCount':
                            valueA = statsA.runCount || 0;
                            valueB = statsB.runCount || 0;
                            break;
                        case 'passPercentage':
                            valueA = parseFloat(statsA.passPercentage) || 0;
                            valueB = parseFloat(statsB.passPercentage) || 0;
                            break;
                        case 'skipCount':
                            valueA = statsA.skipCount || 0;
                            valueB = statsB.skipCount || 0;
                            break;
                        case 'failCount':
                            valueA = statsA.failCount || 0;
                            valueB = statsB.failCount || 0;
                            break;
                        case 'timeoutCount':
                            valueA = statsA.timeoutCount || 0;
                            valueB = statsB.timeoutCount || 0;
                            break;
                        default:
                            valueA = parseFloat(statsA.passPercentage) || 0;
                            valueB = parseFloat(statsB.passPercentage) || 0;
                    }
                }

                const result = sortDirection === 'asc' ? valueA - valueB : valueB - valueA;
                return result;
            });
        }

        // Build sort header
        function buildSortHeader() {
            const getSortButton = ([field, label]) => {
                const isActive = sortField === field;
                const arrow = isActive ? (sortDirection === 'asc' ? '‚Üë' : '‚Üì') : ' '; // Always show space
                return `<div class="stat-item">
                    <button class="sort-button ${isActive ? 'active' : ''}" data-field="${field}" onclick="changeSortOrder('${field}')">
                        <span class="sort-arrow">${arrow}</span>${label}
                    </button>
                </div>`;
            };

            // Check if we're in list/components view or if we have tests to show appropriate headers
            const view = getCurrentView();
            const isListLike = view === 'list' || view === 'components';
            const hasTests = isListLike || (treeData && Object.values(treeData.children).some(folder => Object.keys(folder.tests).length > 0));

            // Special button for Path (left-aligned)
            const getPathButton = (field, label) => {
                const isActive = sortField === field;
                const arrow = isActive ? (sortDirection === 'asc' ? '‚Üë' : '‚Üì') : ' '; // Always show space
                return `<button class="sort-button ${isActive ? 'active' : ''}" data-field="${field}" onclick="changeSortOrder('${field}')" style="justify-content: flex-start;">
                    <span class="sort-arrow">${arrow}</span>${label}
                </button>`;
            };

            // Generate appropriate stats buttons based on view type
            const commonFields = [['runCount', 'Runs'], ['passPercentage', 'Pass %'], ['skipCount', 'Skips'], ['failCount', 'Failures'], ['timeoutCount', 'Timeouts']];
            const specificFields = hasTests ? [['min', 'Min'], ['avg', 'Avg'], ['max', 'Max']] : [['testCount', 'Tests']];
            const statsFields = [...specificFields, ...commonFields];

            const statsButtons = statsFields.map(getSortButton).join('');

            return `<div class="sort-header">
                <div class="tree-name">${getPathButton('name', 'Path')}</div>
                <div class="tree-stats">
                    ${statsButtons}
                </div>
            </div>`;
        }

        // Change sort order
        function changeSortOrder(field) {
            if (sortField === field) {
                sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                sortField = field;
                // Default to descending for most fields, ascending for path and pass percentage
                if (field === 'name' || field === 'passPercentage') {
                    sortDirection = 'asc';
                } else {
                    sortDirection = 'desc';
                }
            }
            changeView();
        }

        // Calculate parallel platform breakdown for test data
        function calculateParallelPlatformBreakdown(testData) {
            const platforms = {};

            if (currentData && currentData.testRuns && testData.testId !== undefined) {
                const testGroup = currentData.testRuns[testData.testId];
                if (testGroup) {
                    for (let statusId = 0; statusId < testGroup.length; statusId++) {
                        const statusGroup = testGroup[statusId];
                        if (!statusGroup) continue;

                        const status = currentData.tables.statuses[statusId];

                        // Only count parallel statuses
                        if (!status || !status.includes('PARALLEL')) continue;

                        for (let i = 0; i < statusGroup.taskIdIds.length; i++) {
                            const taskIdIndex = statusGroup.taskIdIds[i];
                            const jobName = currentData.tables.jobNames[currentData.taskInfo.jobNameIds[taskIdIndex]];
                            const platform = extractPlatform(jobName) || 'unknown';

                            if (!platforms[platform]) {
                                platforms[platform] = {
                                    parallelFails: 0,
                                    parallelTimeouts: 0,
                                    parallelPasses: 0
                                };
                            }

                            if (status === 'FAIL-PARALLEL') {
                                platforms[platform].parallelFails++;
                            } else if (status === 'TIMEOUT-PARALLEL') {
                                platforms[platform].parallelTimeouts++;
                            } else if (status === 'PASS-PARALLEL') {
                                platforms[platform].parallelPasses++;
                            }
                        }
                    }
                }
            }

            return platforms;
        }

        // Calculate platform timing breakdown for test data
        function calculateTestPlatformTimingBreakdown(testData) {
            const platforms = {};

            // Use global currentData to avoid creating run objects just for tooltips
            if (testData.testId !== undefined) {
                const testGroup = currentData.testRuns[testData.testId];

                if (testGroup) {
                    // Process each status group
                    for (let statusId = 0; statusId < testGroup.length; statusId++) {
                        const statusGroup = testGroup[statusId];
                        if (!statusGroup) continue;

                        const status = currentData.tables.statuses[statusId];
                        const isPass = status && status.startsWith('PASS');

                        // Only track timing for passing tests
                        if (isPass) {
                            for (let i = 0; i < statusGroup.taskIdIds.length; i++) {
                                const taskIdIndex = statusGroup.taskIdIds[i];
                                const jobName = currentData.tables.jobNames[currentData.taskInfo.jobNameIds[taskIdIndex]];
                                const platform = extractPlatform(jobName) || 'unknown';
                                const duration = statusGroup.durations[i];

                                if (!platforms[platform]) {
                                    platforms[platform] = {
                                        durations: [],
                                        min: Infinity,
                                        max: 0,
                                        total: 0,
                                        count: 0
                                    };
                                }

                                platforms[platform].durations.push(duration);
                                platforms[platform].total += duration;
                                platforms[platform].count++;
                                platforms[platform].min = Math.min(platforms[platform].min, duration);
                                platforms[platform].max = Math.max(platforms[platform].max, duration);
                            }
                        }
                    }
                }

                // Calculate averages and handle edge cases
                Object.keys(platforms).forEach(platform => {
                    const p = platforms[platform];
                    p.avg = p.count > 0 ? p.total / p.count : 0;
                    if (p.min === Infinity) p.min = 0;
                });
            }

            return platforms;
        }

        // Calculate platform breakdown for test data
        function calculateTestPlatformBreakdown(testData) {
            const platforms = {};

            // Use global currentData to avoid creating run objects just for tooltips
            if (testData.testId !== undefined) {
                const testGroup = currentData.testRuns[testData.testId];

                if (testGroup) {
                    // Process each status group
                    for (let statusId = 0; statusId < testGroup.length; statusId++) {
                        const statusGroup = testGroup[statusId];
                        if (!statusGroup) continue;

                        const status = currentData.tables.statuses[statusId];
                        const isSkip = status === 'SKIP';
                        const isTimeout = status && status.startsWith('TIMEOUT');
                        const isFail = status && !status.startsWith('PASS') && !status.startsWith('TIMEOUT') && !['SKIP', 'CRASH', 'EXPECTED-FAIL'].includes(status);

                        for (let i = 0; i < statusGroup.taskIdIds.length; i++) {
                            // Skip run-if annotations early (platform-irrelevant tests)
                            if (isSkip && currentData.tables.messages[statusGroup.messageIds?.[i]]?.startsWith('run-if')) {
                                continue; // Don't count run-if skips at all
                            }

                            const taskIdIndex = statusGroup.taskIdIds[i];
                            const jobName = currentData.tables.jobNames[currentData.taskInfo.jobNameIds[taskIdIndex]];
                            const platform = extractPlatform(jobName) || 'unknown';
                            const duration = statusGroup.durations[i];
                            const isTimeoutByDuration = status === 'UNKNOWN' && duration > 300000;

                            if (!platforms[platform]) {
                                platforms[platform] = {
                                    total: 0,
                                    skips: 0,
                                    failures: 0,
                                    timeouts: 0,
                                    passes: 0
                                };
                            }

                            platforms[platform].total++;
                            if (isSkip) {
                                platforms[platform].skips++;
                            } else if (isTimeout || isTimeoutByDuration) {
                                platforms[platform].timeouts++;
                            } else if (isFail) {
                                platforms[platform].failures++;
                            } else {
                                platforms[platform].passes++;
                            }
                        }
                    }
                }
            } else if (testData.runs) {
                // Fall back to runs if raw data is no longer available
                testData.runs.forEach(run => {
                    // Skip run-if annotations (platform-irrelevant tests)
                    if (run.isSkip && run.message?.startsWith('run-if')) {
                        return; // Don't count run-if skips at all
                    }

                    const platform = extractPlatform(run.jobName) || 'unknown';
                    if (!platforms[platform]) {
                        platforms[platform] = {
                            total: 0,
                            skips: 0,
                            failures: 0,
                            timeouts: 0,
                            passes: 0
                        };
                    }

                    platforms[platform].total++;
                    if (run.isSkip) {
                        platforms[platform].skips++;
                    } else if (run.isTimeout) {
                        platforms[platform].timeouts++;
                    } else if (run.isFail) {
                        platforms[platform].failures++;
                    } else {
                        platforms[platform].passes++;
                    }
                });
            }

            return platforms;
        }

        // Calculate platform breakdown for folder data (recursive)
        function calculateFolderPlatformBreakdown(node) {
            const platforms = {};

            // Collect from tests
            Object.values(node.tests).forEach(test => {
                const testBreakdown = calculateTestPlatformBreakdown(test.data);
                Object.entries(testBreakdown).forEach(([platform, counts]) => {
                    if (!platforms[platform]) {
                        platforms[platform] = { skips: 0, failures: 0, timeouts: 0, passes: 0, total: 0 };
                    }
                    platforms[platform].skips += counts.skips;
                    platforms[platform].failures += counts.failures;
                    platforms[platform].timeouts += counts.timeouts;
                    platforms[platform].passes += counts.passes;
                    platforms[platform].total += counts.total;
                });
            });

            // Collect from child folders
            Object.values(node.children).forEach(child => {
                const childBreakdown = calculateFolderPlatformBreakdown(child);
                Object.entries(childBreakdown).forEach(([platform, counts]) => {
                    if (!platforms[platform]) {
                        platforms[platform] = { skips: 0, failures: 0, timeouts: 0, passes: 0, total: 0 };
                    }
                    platforms[platform].skips += counts.skips;
                    platforms[platform].failures += counts.failures;
                    platforms[platform].timeouts += counts.timeouts;
                    platforms[platform].passes += counts.passes;
                    platforms[platform].total += counts.total;
                });
            });

            return platforms;
        }

        // Get skip message counts for a test (excluding run-if annotations)
        function getSkipMessageCounts(testId) {
            const messageCounts = new Map();
            if (!currentData || !currentData.testRuns || !currentData.testRuns[testId]) {
                return [];
            }

            const testGroup = currentData.testRuns[testId];

            // Find SKIP status ID
            const skipStatusId = currentData.tables.statuses.indexOf('SKIP');
            if (skipStatusId === -1) return [];

            const statusGroup = testGroup[skipStatusId];
            if (!statusGroup || !statusGroup.messageIds) return [];

            // Count messages, excluding run-if (platform-specific tests that are irrelevant)
            statusGroup.messageIds.forEach(messageId => {
                if (messageId !== null) {
                    const message = currentData.tables.messages[messageId];
                    // Only include skip-if and other skip annotations, not run-if
                    if (message && !message.startsWith('run-if')) {
                        messageCounts.set(message, (messageCounts.get(message) || 0) + 1);
                    }
                }
            });

            // Convert to array and sort by count (descending)
            return Array.from(messageCounts.entries())
                .sort((a, b) => b[1] - a[1])
                .map(([message, count]) => ({ message, count }));
        }

        // Helper to truncate long messages for display in tooltips
        function truncateMessage(message, maxLength = 100) {
            if (!message) return '';
            const firstLine = message.split('\n')[0];
            if (firstLine.length > maxLength) {
                return firstLine.substring(0, maxLength) + '...';
            } else if (message.includes('\n')) {
                return firstLine + '...';
            }
            return firstLine;
        }

        // Get failure message counts for a test
        function getFailureMessageCounts(testId) {
            const messageCounts = new Map();

            if (!currentData || !currentData.testRuns || !currentData.testRuns[testId]) {
                return [];
            }

            const testGroup = currentData.testRuns[testId];

            // Find all FAIL* status IDs
            const failStatusIds = currentData.tables.statuses
                .map((status, idx) => status.startsWith('FAIL') ? idx : -1)
                .filter(idx => idx !== -1);

            if (failStatusIds.length === 0) return [];

            // Collect messages from all failure statuses
            failStatusIds.forEach(statusId => {
                const statusGroup = testGroup[statusId];
                if (statusGroup && statusGroup.messageIds) {
                    statusGroup.messageIds.forEach(messageId => {
                        if (messageId !== null) {
                            const message = currentData.tables.messages[messageId];
                            if (message) {
                                messageCounts.set(message, (messageCounts.get(message) || 0) + 1);
                            }
                        }
                    });
                }
            });

            // Convert to array and sort by count (descending)
            return Array.from(messageCounts.entries())
                .sort((a, b) => b[1] - a[1])
                .map(([message, count]) => ({ message, count }));
        }

        // Get crash data for a test
        function getCrashData(testId) {
            if (!currentData || !currentData.testRuns || !currentData.testRuns[testId]) {
                return { signatures: [], minidumps: [] };
            }

            const testGroup = currentData.testRuns[testId];

            // Find CRASH status ID
            const crashStatusId = currentData.tables.statuses.indexOf('CRASH');
            if (crashStatusId === -1) return { signatures: [], minidumps: [] };

            const statusGroup = testGroup[crashStatusId];
            if (!statusGroup || !statusGroup.crashSignatureIds) return { signatures: [], minidumps: [] };

            // Collect unique signatures with counts
            const signatureCounts = new Map();
            statusGroup.crashSignatureIds.forEach(sigId => {
                if (sigId !== null) {
                    const signature = currentData.tables.crashSignatures[sigId];
                    if (signature) {
                        signatureCounts.set(signature, (signatureCounts.get(signature) || 0) + 1);
                    }
                }
            });

            // Collect unique minidumps
            const minidumps = [...new Set(statusGroup.minidumps.filter(m => m !== null))];

            return {
                signatures: Array.from(signatureCounts.entries())
                    .sort((a, b) => b[1] - a[1])
                    .map(([signature, count]) => ({ signature, count })),
                minidumps: minidumps
            };
        }

        // Generate tooltip content for platform breakdown
        function generateTooltipContent(platforms, type, testData, testPath) {
            // Handle timing tooltips differently
            if (['min', 'avg', 'max'].includes(type)) {
                const sortedPlatforms = Object.entries(platforms)
                    .filter(([platform, data]) => data.count > 0)
                    .sort(([,a], [,b]) => b[type] - a[type]);

                if (sortedPlatforms.length === 0) {
                    return '';
                }

                const typeLabel = type === 'min' ? 'Minimum Time' : type === 'avg' ? 'Average Time' : 'Maximum Time';
                let content = `<strong>${typeLabel} by Platform:</strong><br/>`;

                sortedPlatforms.forEach(([platform, data]) => {
                    const value = data[type];
                    const formattedValue = formatDurationMs(value, true);
                    const percentage = type === 'avg' ? '' : ` (${data.count} run${data.count !== 1 ? 's' : ''})`;
                    content += `<div class="tooltip-platform">`;
                    content += `<span class="tooltip-platform-name">${platform}:</span>`;
                    content += `<span>${formattedValue}${percentage}</span>`;
                    content += `</div>`;
                });

                return content;
            }

            // Handle regular count-based tooltips
            const sortedPlatforms = Object.entries(platforms)
                .filter(([platform, counts]) => counts[type] > 0)
                .sort(([,a], [,b]) => b[type] - a[type]);

            if (sortedPlatforms.length === 0) {
                return '';
            }

            const total = sortedPlatforms.reduce((sum, [,counts]) => sum + counts[type], 0);
            const typeLabel = type === 'failures' ? 'Failures' : type === 'skips' ? 'Skips' : 'Timeouts';

            let content = `<strong>${typeLabel} by Platform:</strong><br/>`;

            sortedPlatforms.forEach(([platform, counts]) => {
                const platformName = platforms[platform] || platform;
                const percentage = ((counts[type] / total) * 100).toFixed(1);
                content += `<div class="tooltip-platform">`;
                content += `<span class="tooltip-platform-name">${platform}:</span>`;
                content += `<span>${counts[type]} (${percentage}%)</span>`;
                content += `</div>`;
            });

            // Add skip messages for skips tooltip
            if (type === 'skips' && testData && testData.testId !== undefined) {
                const skipMessageCounts = getSkipMessageCounts(testData.testId);
                if (skipMessageCounts.length > 0) {
                    content += `<div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #555;">`;
                    content += `<strong>Skip reasons:</strong><br/>`;
                    skipMessageCounts.forEach(({message, count}) => {
                        // Remove "skip-if:" prefix and following whitespace
                        const displayMessage = message.replace(/^skip-if:\s*/, '');
                        content += `<div style="font-size: 11px; margin-top: 4px; color: #ccc;">`;
                        content += `<span style="font-family: monospace;">${escapeHtml(displayMessage)}</span>`;
                        content += ` <span style="color: #999;">(${count})</span>`;
                        content += `</div>`;
                    });
                    content += `</div>`;
                }
            }

            // Add failure messages for failures tooltip
            if (type === 'failures' && testData && testData.testId !== undefined) {
                const failureMessageCounts = getFailureMessageCounts(testData.testId);
                if (failureMessageCounts.length > 0) {
                    content += `<div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #555;">`;
                    content += `<strong>Failure messages:</strong><br/>`;
                    failureMessageCounts.forEach(({message, count}) => {
                        const displayMessage = truncateMessage(message, 100);
                        content += `<div style="font-size: 11px; margin-top: 4px; color: #ccc;">`;
                        content += `<span style="font-family: monospace; word-break: break-word;">${escapeHtml(displayMessage)}</span>`;
                        content += ` <span style="color: #999;">(${count})</span>`;
                        content += `</div>`;
                    });
                    content += `</div>`;
                }
            }

            // Add parallel failure summary at the end for failures tooltip on individual tests
            if (type === 'failures' && testData && testData.stats) {
                const stats = testData.stats;
                const parallelTotalRuns = (stats.parallelFailCount || 0) + (stats.parallelTimeoutCount || 0) + (stats.parallelPassCount || 0);
                const parallelProblematicCount = (stats.parallelFailCount || 0) + (stats.parallelTimeoutCount || 0);
                const parallelFailPercentage = stats.parallelFailPercentage || 0;

                if (parallelTotalRuns > 0) {
                    let tooltipDetails = [];
                    if (stats.parallelFailCount > 0) tooltipDetails.push(`${stats.parallelFailCount} failures`);
                    if (stats.parallelTimeoutCount > 0) tooltipDetails.push(`${stats.parallelTimeoutCount} timeouts`);

                    content += `<div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #ddd;">`;
                    content += `<strong>Parallel runs:</strong> ${parallelProblematicCount}/${parallelTotalRuns} had issues (${parallelFailPercentage}%)`;
                    if (tooltipDetails.length > 0) {
                        content += `<br/>${tooltipDetails.join(', ')}`;
                    }
                    if ((stats.sequentialPassCount || 0) > 0) {
                        content += `<br/>${stats.sequentialPassCount} sequential passes`;
                    }
                    content += `</div>`;

                    // Add per-platform parallel breakdown for tests with >= 10% parallel fail rate
                    if (parallelFailPercentage >= 10 && testPath && typeof aggregatedData !== 'undefined' && aggregatedData[testPath]) {
                        const platformBreakdown = calculateParallelPlatformBreakdown(aggregatedData[testPath]);
                        const platforms = Object.entries(platformBreakdown)
                            .filter(([platform, counts]) => (counts.parallelFails + counts.parallelTimeouts) > 0)
                            .sort(([,a], [,b]) => (b.parallelFails + b.parallelTimeouts) - (a.parallelFails + a.parallelTimeouts));

                        if (platforms.length > 0) {
                            content += `<div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #ddd;">`;
                            content += `<strong>Parallel issues by platform:</strong>`;
                            platforms.forEach(([platform, counts]) => {
                                const totalParallel = counts.parallelFails + counts.parallelTimeouts + counts.parallelPasses;
                                const problemCount = counts.parallelFails + counts.parallelTimeouts;
                                const percentage = totalParallel > 0 ? Math.round((problemCount * 100) / totalParallel) : 0;
                                content += `<br/>${platform}: ${problemCount}/${totalParallel} (${percentage}%)`;
                            });
                            content += `</div>`;
                        }
                    }
                }

                // Add crash count and breakdown
                if (testData.testId !== undefined) {
                    const crashData = getCrashData(testData.testId);
                    const totalCrashes = crashData.signatures.reduce((sum, sig) => sum + sig.count, 0);

                    if (totalCrashes > 0) {
                        content += `<div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #ddd;">`;
                        content += `<strong>Crashes: ${totalCrashes}</strong><br/>`;

                        // Add crash breakdown by platform
                        const crashesByPlatform = {};
                        if (currentData && currentData.testRuns && currentData.testRuns[testData.testId]) {
                            const testGroup = currentData.testRuns[testData.testId];
                            const crashStatusId = currentData.tables.statuses.indexOf('CRASH');
                            if (crashStatusId !== -1) {
                                const statusGroup = testGroup[crashStatusId];
                                if (statusGroup) {
                                    for (let i = 0; i < statusGroup.taskIdIds.length; i++) {
                                        const taskIdIndex = statusGroup.taskIdIds[i];
                                        const jobName = currentData.tables.jobNames[currentData.taskInfo.jobNameIds[taskIdIndex]];
                                        const platform = extractPlatform(jobName) || 'unknown';
                                        crashesByPlatform[platform] = (crashesByPlatform[platform] || 0) + 1;
                                    }
                                }
                            }
                        }

                        const sortedPlatforms = Object.entries(crashesByPlatform)
                            .sort((a, b) => b[1] - a[1]);

                        sortedPlatforms.forEach(([platform, count]) => {
                            const percentage = ((count / totalCrashes) * 100).toFixed(1);
                            content += `<div class="tooltip-platform">`;
                            content += `<span class="tooltip-platform-name">${platform}:</span>`;
                            content += `<span>${count} (${percentage}%)</span>`;
                            content += `</div>`;
                        });

                        content += `</div>`;
                    }
                }
            }

            // Add parallel/sequential breakdown for timeouts tooltip on individual tests
            if (type === 'timeouts' && testData && testData.stats) {
                const stats = testData.stats;
                const parallelTimeouts = stats.parallelTimeoutCount || 0;
                const sequentialTimeouts = stats.sequentialTimeoutCount || 0;
                const totalTimeouts = stats.timeoutCount || 0;

                if (parallelTimeouts > 0 || sequentialTimeouts > 0) {
                    content += `<div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #ddd;">`;
                    content += `<strong>Breakdown:</strong>`;
                    if (parallelTimeouts > 0) {
                        content += `<br/>${parallelTimeouts} in parallel execution`;
                    }
                    if (sequentialTimeouts > 0) {
                        content += `<br/>${sequentialTimeouts} in sequential execution`;
                    }
                    // Show unclassified timeouts if any
                    const unclassified = totalTimeouts - parallelTimeouts - sequentialTimeouts;
                    if (unclassified > 0) {
                        content += `<br/>${unclassified} unclassified`;
                    }
                    content += `</div>`;
                }
            }

            return content;
        }

        // Build total summary row
        function buildTotalSummaryRow(totalStats) {
            // Tooltips will be computed lazily on hover

            let html = `<div class="tree-row total-row">`;
            html += `<div class="tree-name"><strong>üìä Total</strong></div>`;
            html += `<div class="tree-stats">`;

            // Check if we're showing test-specific columns or folder-specific columns
            const hasTests = treeData && Object.values(treeData.children).some(folder => Object.keys(folder.tests).length > 0);

            if (hasTests) {
                // Test view: show avg/max columns
                html += generateStatItem('Avg', '‚Äî');
                html += generateStatItem('Max', '‚Äî');
            } else {
                // Folder view: show test count
                html += generateStatItem('Tests', formatNumber(totalStats.testCount));
            }

            html += generateStatItem('Runs', formatNumber(totalStats.runCount), totalStats.runCount === 0 ? 'fail' : '', '', `Total duration of passing runs: ${formatDurationMs(totalStats.totalDuration, totalStats.runCount > 0)}`);

            const totalPassPercentageClass = totalStats.passPercentage < 100 && totalStats.runCount > 0 ? (totalStats.passPercentage === 0 ? 'fail' : '') : 'zero';
            html += generateStatItem('Pass %', `${totalStats.passPercentage}%`, totalPassPercentageClass);

            // Skips with lazy tooltip
            html += generateStatItem('Skips', formatNumber(totalStats.skipCount), 'skip', totalStats.skipCount > 0 ? 'lazy-tooltip' : '', '', ' data-total-root="true" data-tooltip-type="skips"');

            // Failures with lazy tooltip
            const totalFailClass = totalStats.failCount > 0 ? 'fail' : 'zero';
            html += generateStatItem('Failures', formatNumber(totalStats.failCount), totalFailClass, totalStats.failCount > 0 ? 'lazy-tooltip' : '', '', ' data-total-root="true" data-tooltip-type="failures"');

            // Timeouts with lazy tooltip
            const totalTimeoutClass = totalStats.timeoutCount > 0 ? 'timeout' : 'zero';
            html += generateStatItem('Timeouts', formatNumber(totalStats.timeoutCount), totalTimeoutClass, totalStats.timeoutCount > 0 ? 'lazy-tooltip' : '', '', ' data-total-root="true" data-tooltip-type="timeouts"');

            html += `</div>`;
            html += `</div>`;

            return html;
        }

        // Check if a node or its children contain matches
        function containsMatch(node, searchTerm, currentPath = '') {
            if (!searchTerm) return true;

            const lowerSearch = searchTerm.toLowerCase();

            // Check tests in this node
            for (const testName of Object.keys(node.tests)) {
                const fullPath = currentPath ? `${currentPath}/${testName}` : testName;
                if (fullPath.toLowerCase().includes(lowerSearch)) {
                    return true;
                }
            }

            // Check child folders recursively
            for (const childName of Object.keys(node.children)) {
                const childPath = currentPath ? `${currentPath}/${childName}` : childName;
                if (containsMatch(node.children[childName], searchTerm, childPath)) {
                    return true;
                }
            }

            return false;
        }

        // Calculate filtered statistics for search results
        function calculateFilteredStats(node, searchTerm, currentPath = '') {
            let filteredStats = {
                testCount: 0,
                runCount: 0,
                passCount: 0,
                skipCount: 0,
                failCount: 0,
                timeoutCount: 0,
                passPercentage: 0,
                totalDuration: 0
            };

            // Count tests that match the search (or all tests if no search term)
            for (const testName of Object.keys(node.tests)) {
                const fullPath = currentPath ? `${currentPath}/${testName}` : testName;
                const matchesSearch = !searchTerm || fullPath.toLowerCase().includes(searchTerm.toLowerCase());

                if (matchesSearch) {
                    const test = node.tests[testName];
                    const testData = aggregatedData[test.path];
                    if (testData) {
                        filteredStats.testCount++;
                        filteredStats.runCount += testData.stats.runCount;
                        filteredStats.passCount += testData.stats.passCount;
                        filteredStats.skipCount += testData.stats.skipCount;
                        filteredStats.failCount += testData.stats.failCount;
                        filteredStats.timeoutCount += testData.stats.timeoutCount;
                        filteredStats.totalDuration += testData.stats.totalDuration || 0;
                    }
                }
            }

            // Recursively include stats from child folders that contain matches (or all if no search)
            for (const childName of Object.keys(node.children)) {
                const childPath = currentPath ? `${currentPath}/${childName}` : childName;
                const shouldIncludeChild = !searchTerm || containsMatch(node.children[childName], searchTerm, childPath);

                if (shouldIncludeChild) {
                    const childStats = calculateFilteredStats(node.children[childName], searchTerm, childPath);
                    filteredStats.testCount += childStats.testCount;
                    filteredStats.runCount += childStats.runCount;
                    filteredStats.passCount += childStats.passCount;
                    filteredStats.skipCount += childStats.skipCount;
                    filteredStats.failCount += childStats.failCount;
                    filteredStats.timeoutCount += childStats.timeoutCount;
                    filteredStats.totalDuration += childStats.totalDuration || 0;
                }
            }

            // Calculate pass percentage
            filteredStats.passPercentage = calculatePassPercentage(filteredStats.passCount, filteredStats.runCount);

            return filteredStats;
        }

        // Build HTML for tree rows
        function buildTreeHTML(node, level = 0, parentPath = '', searchTerm = '') {
            let html = '';
            const lowerSearchTerm = searchTerm.toLowerCase();

            // Add header only at root level
            if (level === 0) {
                html += buildSortHeader();
                // Add total summary row - always use calculateFilteredStats (works for both filtered and unfiltered)
                const statsToShow = calculateFilteredStats(node, searchTerm);
                html += buildTotalSummaryRow(statsToShow);
            }

            // Sort folders
            const sortedFolders = sortItems(Object.keys(node.children), true, node);

            // Build rows for folders
            for (const folderName of sortedFolders) {
                let folder = node.children[folderName];
                let displayName = folderName;
                let collapsedPath = folderName;

                // Skip folder if it doesn't contain matches
                if (searchTerm && !containsMatch(folder, searchTerm, parentPath ? `${parentPath}/${folderName}` : folderName)) {
                    continue;
                }

                // Collapse single-child folders into one line
                while (Object.keys(folder.children).length === 1 && Object.keys(folder.tests).length === 0) {
                    const childName = Object.keys(folder.children)[0];
                    collapsedPath = `${collapsedPath}/${childName}`;
                    displayName = `${displayName}/${childName}`;
                    folder = folder.children[childName];
                }

                const folderPath = parentPath ? `${parentPath}/${collapsedPath}` : collapsedPath;
                const isExpanded = expandedRows.has(folderPath);

                // Always use calculateFilteredStats (works for both filtered and unfiltered)
                const folderStats = calculateFilteredStats(folder, searchTerm, folderPath);

                html += `<div class="tree-row folder-row" data-path="${folderPath}" data-level="${level}">`;
                html += `<div class="tree-name">`;
                html += `<span class="tree-indent" style="width: ${level * 20}px"></span>`;
                html += `<span class="folder-icon ${isExpanded ? 'expanded' : ''}"></span>`;
                html += `<strong>${displayName}/</strong>`;
                html += generateFolderButtons(folderPath);
                html += `</div>`;
                html += `<div class="tree-stats">`;
                html += generateStatItem('Tests', formatNumber(folderStats.testCount));
                html += generateStatItem('Runs', formatNumber(folderStats.runCount), folderStats.runCount === 0 ? 'fail' : '', '', `Total duration of passing runs: ${formatDurationMs(folderStats.totalDuration, folderStats.runCount > 0)}`);

                const folderPassPercentageClass = folderStats.passPercentage < 100 && folderStats.runCount > 0 ? (folderStats.passPercentage === 0 ? 'fail' : '') : 'zero';
                html += generateStatItem('Pass %', `${folderStats.passPercentage}%`, folderPassPercentageClass);

                // Skips with lazy tooltip
                html += generateStatItem('Skips', formatNumber(folderStats.skipCount), 'skip', folderStats.skipCount > 0 ? 'lazy-tooltip' : '', '', ` data-folder-path="${folderPath}" data-tooltip-type="skips"`);

                // Failures with lazy tooltip
                const folderFailClass = folderStats.failCount > 0 ? 'fail' : 'zero';
                html += generateStatItem('Failures', formatNumber(folderStats.failCount), folderFailClass, folderStats.failCount > 0 ? 'lazy-tooltip' : '', '', ` data-folder-path="${folderPath}" data-tooltip-type="failures"`);

                // Timeouts with lazy tooltip
                const folderTimeoutClass = folderStats.timeoutCount > 0 ? 'timeout' : 'zero';
                html += generateStatItem('Timeouts', formatNumber(folderStats.timeoutCount), folderTimeoutClass, folderStats.timeoutCount > 0 ? 'lazy-tooltip' : '', '', ` data-folder-path="${folderPath}" data-tooltip-type="timeouts"`);

                html += `</div>`;
                html += `</div>`;

                if (isExpanded) {
                    html += buildTreeHTML(folder, level + 1, folderPath, searchTerm);
                }
            }

            // Sort tests
            const sortedTests = sortItems(Object.keys(node.tests), false, node);

            // Build rows for tests
            for (const testName of sortedTests) {
                const test = node.tests[testName];
                const testPath = test.path;

                // Skip test if it doesn't match search
                if (searchTerm && !testPath.toLowerCase().includes(lowerSearchTerm)) {
                    continue;
                }
                const hasChart = chartRows.has(testPath);

                html += `<div class="tree-row test-row" data-path="${testPath}" data-level="${level}">`;
                html += `<div class="tree-name">`;
                html += `<span class="tree-indent" style="width: ${level * 20}px"></span>`;
                html += `<span class="test-icon"></span>`;
                const component = test.data.component;
                const componentTitle = component ? ` title="Component: ${escapeHtml(component)}"` : '';
                html += `<span${componentTitle}>${testName}</span>`;
                html += generateTestButtons(testPath);
                html += `</div>`;
                html += `<div class="tree-stats">`;
                const hasRuns = test.data.stats.runCount > 0;
                html += generateStatsHtml(test.data.stats, testPath, hasRuns);
                html += `</div>`;
                html += `</div>`;

                if (hasChart) {
                    html += generateChartHtml(testPath);
                }

            }

            return html;
        }

        // Sort test list based on current sortField and sortDirection
        function sortTestList(testList) {
            return testList.sort((a, b) => {
                let valueA, valueB;

                switch(sortField) {
                    case 'name':
                        valueA = a.testPath;
                        valueB = b.testPath;
                        break;
                    case 'avg':
                        valueA = a.avgDuration;
                        valueB = b.avgDuration;
                        break;
                    case 'max':
                        valueA = a.stats.max || 0;
                        valueB = b.stats.max || 0;
                        break;
                    case 'min':
                        valueA = a.stats.min || 0;
                        valueB = b.stats.min || 0;
                        break;
                    case 'runCount':
                        valueA = a.stats.runCount || 0;
                        valueB = b.stats.runCount || 0;
                        break;
                    case 'passPercentage':
                        valueA = parseFloat(a.stats.passPercentage) || 0;
                        valueB = parseFloat(b.stats.passPercentage) || 0;
                        break;
                    case 'skipCount':
                        valueA = a.stats.skipCount || 0;
                        valueB = b.stats.skipCount || 0;
                        break;
                    case 'failCount':
                        valueA = a.stats.failCount || 0;
                        valueB = b.stats.failCount || 0;
                        break;
                    case 'timeoutCount':
                        valueA = a.stats.timeoutCount || 0;
                        valueB = b.stats.timeoutCount || 0;
                        break;
                    default:
                        // Default sort by total failures (failCount + timeoutCount)
                        valueA = a.totalFailures;
                        valueB = b.totalFailures;
                        break;
                }

                if (sortField === 'name') {
                    return sortDirection === 'asc' ? valueA.localeCompare(valueB) : valueB.localeCompare(valueA);
                }

                return sortDirection === 'asc' ? valueA - valueB : valueB - valueA;
            });
        }

        // Render components view - tests grouped by bugzilla component
        function renderComponentsView() {
            if (!aggregatedData) {
                document.getElementById('no-data').style.display = 'block';
                document.getElementById('tree-container').style.display = 'none';
                return;
            }

            document.getElementById('no-data').style.display = 'none';
            document.getElementById('tree-container').style.display = 'block';

            const searchTerm = document.getElementById('search-box').value.toLowerCase().trim();

            // Group tests by component
            const componentGroups = {};
            const testsWithoutComponent = [];

            for (const testPath in aggregatedData) {
                const testData = aggregatedData[testPath];
                if (searchTerm && !testPath.toLowerCase().includes(searchTerm)) {
                    continue;
                }

                const component = testData.component || '(no component)';
                if (!componentGroups[component]) {
                    componentGroups[component] = {
                        tests: [],
                        failedTestCount: 0,
                        totalStats: {
                            runCount: 0,
                            failCount: 0,
                            timeoutCount: 0,
                            skipCount: 0,
                            passCount: 0
                        }
                    };
                }

                componentGroups[component].tests.push({ testPath, data: testData });

                // Accumulate stats
                const stats = testData.stats || computeTestStats(testData.testId);
                componentGroups[component].totalStats.runCount += stats.runCount || 0;
                componentGroups[component].totalStats.failCount += stats.failCount || 0;
                componentGroups[component].totalStats.timeoutCount += stats.timeoutCount || 0;
                componentGroups[component].totalStats.skipCount += stats.skipCount || 0;
                componentGroups[component].totalStats.passCount += stats.passCount || 0;

                // Count tests with failures or timeouts
                if ((stats.failCount || 0) > 0 || (stats.timeoutCount || 0) > 0) {
                    componentGroups[component].failedTestCount++;
                }
            }

            // Sort components based on current sortField and sortDirection
            const sortedComponents = Object.entries(componentGroups).sort(([nameA, groupA], [nameB, groupB]) => {
                let valueA, valueB;

                switch(sortField) {
                    case 'name':
                        valueA = nameA;
                        valueB = nameB;
                        break;
                    case 'runCount':
                        valueA = groupA.totalStats.runCount || 0;
                        valueB = groupB.totalStats.runCount || 0;
                        break;
                    case 'passPercentage':
                        const passPercentageA = groupA.totalStats.runCount > 0
                            ? Math.round((groupA.totalStats.passCount / groupA.totalStats.runCount) * 100)
                            : 0;
                        const passPercentageB = groupB.totalStats.runCount > 0
                            ? Math.round((groupB.totalStats.passCount / groupB.totalStats.runCount) * 100)
                            : 0;
                        valueA = passPercentageA;
                        valueB = passPercentageB;
                        break;
                    case 'skipCount':
                        valueA = groupA.totalStats.skipCount || 0;
                        valueB = groupB.totalStats.skipCount || 0;
                        break;
                    case 'failCount':
                        valueA = groupA.totalStats.failCount || 0;
                        valueB = groupB.totalStats.failCount || 0;
                        break;
                    case 'timeoutCount':
                        valueA = groupA.totalStats.timeoutCount || 0;
                        valueB = groupB.totalStats.timeoutCount || 0;
                        break;
                    default:
                        // Default sort by total failures (failCount + timeoutCount)
                        valueA = (groupA.totalStats.failCount || 0) + (groupA.totalStats.timeoutCount || 0);
                        valueB = (groupB.totalStats.failCount || 0) + (groupB.totalStats.timeoutCount || 0);
                        break;
                }

                if (sortField === 'name') {
                    return sortDirection === 'asc' ? valueA.localeCompare(valueB) : valueB.localeCompare(valueA);
                }

                return sortDirection === 'asc' ? valueA - valueB : valueB - valueA;
            });

            // Generate HTML
            let html = '<div class="tree-table">';
            html += buildSortHeader();

            // Render each component group
            sortedComponents.forEach(([componentName, group]) => {
                const isExpanded = expandedRows.has(componentName);

                // Component header row
                html += `<div class="tree-row folder-row" data-path="${escapeHtml(componentName)}">`;
                html += `<div class="tree-name">`;
                html += `<span class="folder-icon ${isExpanded ? 'expanded' : ''}"></span>`;
                html += `<strong>${escapeHtml(componentName)}</strong>`;
                if (group.failedTestCount > 0) {
                    html += ` <span style="color: #888;">(${group.failedTestCount} test${group.failedTestCount !== 1 ? 's' : ''} failed, out of ${group.tests.length})</span>`;
                } else {
                    html += ` <span style="color: #888;">(${group.tests.length} test${group.tests.length !== 1 ? 's' : ''})</span>`;
                }
                html += `</div>`;
                html += `<div class="tree-stats">`;

                // Show aggregate stats for component
                const totalStats = group.totalStats;
                const passPercentage = totalStats.runCount > 0
                    ? Math.round((totalStats.passCount / totalStats.runCount) * 100)
                    : 0;

                html += generateStatItem('Runs', formatNumber(totalStats.runCount));
                html += generateStatItem('Pass %', `${passPercentage}%`, passPercentage < 100 && totalStats.runCount > 0 ? (passPercentage === 0 ? 'fail' : '') : 'zero');
                html += generateStatItem('Skips', formatNumber(totalStats.skipCount), 'skip');
                html += generateStatItem('Failures', formatNumber(totalStats.failCount), totalStats.failCount > 0 ? 'fail' : 'zero');
                html += generateStatItem('Timeouts', formatNumber(totalStats.timeoutCount), totalStats.timeoutCount > 0 ? 'timeout' : 'zero');

                html += `</div>`;
                html += `</div>`;

                // Only render tests if component is expanded
                if (isExpanded) {
                    // Sort tests within component by current sort order
                    const sortedTests = sortTestList(group.tests.map(t => {
                        const stats = t.data.stats || computeTestStats(t.data.testId);
                        const totalFailures = (stats.failCount || 0) + (stats.timeoutCount || 0);
                        return {
                            testPath: t.testPath,
                            stats: stats,
                            avgDuration: stats.avgDuration,
                            totalFailures: totalFailures
                        };
                    }));

                    // Render tests in this component (only tests not passing 100% or with skips)
                    sortedTests.forEach(test => {
                        const testData = aggregatedData[test.testPath];
                        const hasRuns = test.stats.runCount > 0;

                        // Skip tests that are passing 100%, unless they have been skipped at least once (skip-if, not run-if)
                        if (test.stats.passPercentage === 100 && test.stats.runCount > 0 && (test.stats.skipCount || 0) === 0) {
                            return;
                        }

                        const hasChart = chartRows.has(test.testPath);
                        const componentTitle = testData.component ? ` title="Component: ${escapeHtml(testData.component)}"` : '';

                        html += `<div class="tree-row test-row list-row" data-path="${test.testPath}" data-level="1">`;
                        html += `<div class="tree-name">`;
                        html += `<span class="tree-indent" style="width: 20px"></span>`;
                        html += `<span class="test-icon"></span>`;
                        html += `<span${componentTitle}>${test.testPath}</span>`;
                        html += generateTestButtons(test.testPath);
                        html += `</div>`;
                        html += `<div class="tree-stats">`;
                        html += generateStatsHtml(test.stats, test.testPath, hasRuns);
                        html += `</div>`;
                        html += `</div>`;

                        if (hasChart) {
                            html += generateChartHtml(test.testPath);
                        }
                    });
                }
            });

            html += '</div>';

            document.getElementById('tree-table').innerHTML = html;

            // Add click handlers for folder rows (component headers)
            document.querySelectorAll('.folder-row').forEach(row => {
                row.addEventListener('click', () => toggleFolder(row));
            });

            // Add click handlers for test rows
            document.querySelectorAll('.test-row').forEach(row => {
                row.addEventListener('click', () => toggleTestChart(row));
            });

            // Re-render any open charts
            chartRows.forEach(testPath => {
                renderChart(testPath);
            });

            // Add tooltip handlers
            document.querySelectorAll('.lazy-tooltip').forEach(element => {
                element.addEventListener('mouseenter', handleTooltipMouseEnter);
                element.addEventListener('mouseleave', handleTooltipMouseLeave);
            });
        }

        // Render list view of all tests
        function renderListView() {
            if (!aggregatedData) {
                document.getElementById('no-data').style.display = 'block';
                document.getElementById('tree-container').style.display = 'none';
                return;
            }

            hideError();
            document.getElementById('tree-container').style.display = 'block';

            // Get search term for filtering
            const searchTerm = document.getElementById('search-box').value.toLowerCase().trim();

            // Convert aggregated data to array and calculate metrics
            let testList = Object.entries(aggregatedData).map(([testPath, testData]) => {
                const stats = testData.stats;
                const avgDuration = stats.passCount > 0 ? stats.totalDuration / stats.passCount : 0;
                const totalFailures = stats.failCount + stats.timeoutCount; // Count timeouts as failures
                return {
                    testPath,
                    stats,
                    avgDuration,
                    totalFailures
                };
            }).filter(test => test.stats.runCount > 0 || test.stats.skipCount > 0); // Include tests with runs or skips

            // Apply search filtering if search term exists
            if (searchTerm) {
                testList = testList.filter(test => test.testPath.toLowerCase().includes(searchTerm));
            }

            // Apply sorting using shared function
            testList = sortTestList(testList);

            let html = '<div class="tree-table">';
            html += buildSortHeader();

            // Calculate how many rows to render immediately (viewport + buffer)
            const rowHeight = 28; // From CSS min-height
            const viewportHeight = window.innerHeight;
            const visibleRows = Math.ceil(viewportHeight / rowHeight);
            const bufferRows = 5; // Extra rows for smooth scrolling
            const preRenderCount = Math.min(visibleRows + bufferRows, testList.length);

            // Create rows with immediate rendering for viewport, lazy loading for the rest
            testList.forEach((test, index) => {
                const shouldPreRender = index < preRenderCount;

                html += `<div class="tree-row test-row ${shouldPreRender ? 'list-row' : 'lazy-row'}" data-path="${test.testPath}" data-level="0" data-test-index="${index}">`;

                if (shouldPreRender) {
                    // Render immediately for visible rows
                    const hasRuns = test.stats.runCount > 0;
                    const testData = aggregatedData[test.testPath];
                    const component = testData?.component;
                    const componentTitle = component ? ` title="Component: ${escapeHtml(component)}"` : '';
                    html += `<div class="tree-name">`;
                    html += `<span class="test-icon"></span>`;
                    html += `<span${componentTitle}>${test.testPath}</span>`;
                    html += generateTestButtons(test.testPath);
                    html += `</div>`;
                    html += `<div class="tree-stats">`;
                    // Use avgDuration from test object, not recalculated
                    const statsWithAvgDuration = { ...test.stats, avgDuration: test.avgDuration };
                    html += generateStatsHtml(statsWithAvgDuration, test.testPath, hasRuns);
                    html += `</div>`;
                } else {
                    // Empty structure for lazy loading
                    html += `<div class="tree-name"></div>`;
                    html += `<div class="tree-stats"></div>`;
                }

                html += `</div>`;
            });

            html += '</div>';

            document.getElementById('tree-table').innerHTML = html;

            // Add click handlers to all list rows (both pre-rendered and lazy)
            document.querySelectorAll('.test-row').forEach(row => {
                row.addEventListener('click', (e) => {
                    toggleTestChart(row);
                });
            });

            // Add tooltip handlers to pre-rendered rows
            document.querySelectorAll('.lazy-tooltip').forEach(element => {
                element.addEventListener('mouseenter', handleTooltipMouseEnter);
                element.addEventListener('mouseleave', handleTooltipMouseLeave);
            });

            // Set up Intersection Observer for lazy loading
            setupListObserver(testList);
        }

        // Set up Intersection Observer for lazy loading list rows
        function setupListObserver(testList) {
            // Clean up existing observer
            if (listObserver) {
                listObserver.disconnect();
            }

            // Create new observer with some margin for smoother loading
            listObserver = new IntersectionObserver((entries) => {
                entries.forEach(entry => {
                    if (entry.isIntersecting) {
                        const row = entry.target;
                        const testIndex = parseInt(row.dataset.testIndex);
                        const test = testList[testIndex];

                        if (test && row.classList.contains('lazy-row')) {
                            // Render the actual content
                            renderListRowContent(row, test);
                            // Remove from observation since it's now loaded
                            listObserver.unobserve(row);
                        }
                    }
                });
            }, {
                root: null, // Use viewport as root
                rootMargin: '200px', // Load rows 200px before they become visible
                threshold: 0 // Trigger as soon as any part becomes visible
            });

            // Observe all lazy rows
            document.querySelectorAll('.lazy-row').forEach(row => {
                listObserver.observe(row);
            });
        }

        // Render content for a specific list row
        function renderListRowContent(row, test) {
            const hasRuns = test.stats.runCount > 0;
            const testData = aggregatedData[test.testPath];
            const component = testData?.component;
            const componentTitle = component ? ` title="Component: ${escapeHtml(component)}"` : '';

            // Update the tree-name content
            const treeName = row.querySelector('.tree-name');
            treeName.innerHTML = `
                <span class="test-icon"></span>
                <span${componentTitle}>${test.testPath}</span>
                ${generateTestButtons(test.testPath)}
            `;

            // Update the tree-stats content
            const treeStats = row.querySelector('.tree-stats');
            const statsWithAvgDuration = { ...test.stats, avgDuration: test.avgDuration };
            treeStats.innerHTML = generateStatsHtml(statsWithAvgDuration, test.testPath, hasRuns);

            // Remove lazy-row class to indicate it's loaded
            row.classList.remove('lazy-row');

            // Add tooltip handlers for this row
            row.querySelectorAll('.lazy-tooltip').forEach(element => {
                element.addEventListener('mouseenter', handleTooltipMouseEnter);
                element.addEventListener('mouseleave', handleTooltipMouseLeave);
            });

            // Add chart if expanded
            const hasChart = chartRows.has(test.testPath);
            if (hasChart) {
                row.insertAdjacentHTML('afterend', generateChartHtml(test.testPath));

                // Render the chart
                renderChart(test.testPath);
            }
        }

        // Render the tree
        function renderTree() {
            // Clean up list observer when switching to tree view
            if (listObserver) {
                listObserver.disconnect();
                listObserver = null;
            }

            if (!treeData) {
                document.getElementById('no-data').style.display = 'block';
                document.getElementById('tree-container').style.display = 'none';
                return;
            }

            hideError();
            document.getElementById('tree-container').style.display = 'block';

            const searchTerm = document.getElementById('search-box').value.trim();

            // Auto-expand folders if there's a search term and no folders are currently expanded
            if (searchTerm && expandedRows.size === 0) {
                autoExpandForSearch(searchTerm);
            }

            const treeHTML = buildTreeHTML(treeData, 0, '', searchTerm);
            document.getElementById('tree-table').innerHTML = treeHTML;

            // Add click handlers
            document.querySelectorAll('.folder-row').forEach(row => {
                row.addEventListener('click', () => toggleFolder(row));
            });

            document.querySelectorAll('.test-row').forEach(row => {
                row.addEventListener('click', () => toggleTestChart(row));
            });

            // Re-render any open charts
            chartRows.forEach(testPath => {
                renderChart(testPath);
            });

            // Add lazy tooltip handlers
            document.querySelectorAll('.lazy-tooltip').forEach(element => {
                element.addEventListener('mouseenter', handleTooltipMouseEnter);
                element.addEventListener('mouseleave', handleTooltipMouseLeave);
            });
        }

        // Handle tooltip mouse enter event
        function handleTooltipMouseEnter(event) {
            const element = event.target;
            const tooltipType = element.dataset.tooltipType;

            // Determine the data source
            let platformBreakdown;
            let testData = null;
            if (element.dataset.totalRoot) {
                // Total row - calculate for entire tree
                platformBreakdown = treeData ? calculateFolderPlatformBreakdown(treeData) : {};
            } else if (element.dataset.folderPath) {
                // Folder - find the folder node and calculate breakdown
                const folderPath = element.dataset.folderPath;
                const folderNode = findFolderNode(treeData, folderPath);
                platformBreakdown = folderNode ? calculateFolderPlatformBreakdown(folderNode) : {};
            } else if (element.dataset.testPath) {
                // Test - get the test data and calculate breakdown
                const testPath = element.dataset.testPath;
                testData = aggregatedData[testPath];

                if (['min', 'avg', 'max'].includes(tooltipType)) {
                    // For timing tooltips, use the timing breakdown function
                    platformBreakdown = testData ? calculateTestPlatformTimingBreakdown(testData) : {};
                } else {
                    // For other tooltips, use the regular breakdown function
                    platformBreakdown = testData ? calculateTestPlatformBreakdown(testData) : {};
                }
            }

            // Generate and show tooltip
            const testPath = element.dataset.testPath || null;
            const tooltipContent = generateTooltipContent(platformBreakdown, tooltipType, testData, testPath);
            if (tooltipContent) {
                showTooltip(element, tooltipContent);
            }
        }

        // Handle tooltip mouse leave event
        function handleTooltipMouseLeave(event) {
            hideTooltip();
        }

        // Find folder node by path
        function findFolderNode(node, targetPath) {
            if (node.path === targetPath) {
                return node;
            }

            for (const child of Object.values(node.children)) {
                const found = findFolderNode(child, targetPath);
                if (found) return found;
            }

            return null;
        }

        // Show tooltip
        function showTooltip(element, content) {
            // Remove any existing tooltip
            hideTooltip();

            const tooltip = document.createElement('div');
            tooltip.className = 'dynamic-tooltip';
            tooltip.innerHTML = content;

            document.body.appendChild(tooltip);

            // Position tooltip near the element
            const rect = element.getBoundingClientRect();
            const tooltipRect = tooltip.getBoundingClientRect();

            // Account for scroll position
            const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
            const scrollTop = window.pageYOffset || document.documentElement.scrollTop;

            let left = rect.left + scrollLeft + (rect.width / 2) - (tooltipRect.width / 2);
            let top = rect.top + scrollTop - tooltipRect.height - 8;

            // Adjust if tooltip would go off screen (using viewport coordinates)
            if (left - scrollLeft < 8) left = scrollLeft + 8;
            if (left - scrollLeft + tooltipRect.width > window.innerWidth - 8) {
                left = scrollLeft + window.innerWidth - tooltipRect.width - 8;
            }
            if (top - scrollTop < 8) {
                top = rect.bottom + scrollTop + 8;
            }

            tooltip.style.left = left + 'px';
            tooltip.style.top = top + 'px';
        }

        // Hide tooltip
        function hideTooltip() {
            const existing = document.querySelector('.dynamic-tooltip');
            if (existing) {
                existing.remove();
            }
        }

        // Toggle folder expansion
        function toggleFolder(row) {
            const path = row.dataset.path;

            // Save scroll position before DOM changes
            const scrollTop = window.pageYOffset || document.documentElement.scrollTop;

            if (expandedRows.has(path)) {
                expandedRows.delete(path);
            } else {
                expandedRows.add(path);
            }

            changeView();

            // Restore scroll position after DOM rebuild
            window.scrollTo(0, scrollTop);
        }

        // Toggle test chart
        function toggleTestChart(row) {
            const path = row.dataset.path;

            // Save scroll position before DOM changes
            const scrollTop = window.pageYOffset || document.documentElement.scrollTop;

            if (chartRows.has(path)) {
                chartRows.delete(path);
            } else {
                chartRows.add(path);
            }

            // Check if we're in list/components view
            const view = getCurrentView();
            if (view === 'list' || view === 'components') {
                // In list/components view, toggle chart without full re-render
                toggleListViewChart(row, path);
            } else {
                // In tree view, do full re-render
                changeView();

                // Restore scroll position after DOM rebuild
                window.scrollTo(0, scrollTop);
            }
        }

        // Toggle chart in list view without full re-render
        function toggleListViewChart(row, path) {
            let existingChartRow = row.nextElementSibling;
            if (existingChartRow && existingChartRow.classList.contains('chart-expansion')) {
                // Remove existing chart
                existingChartRow.remove();
            } else {
                // Add new chart using the same structure as tree view
                row.insertAdjacentHTML('afterend', generateChartHtml(path));

                // Render the chart
                renderChart(path);
            }
        }

        // Show visual feedback for successful copy
        function showCopySuccess(button) {
            const originalText = button.textContent;
            button.textContent = '‚úì';
            button.style.color = '#28a745';
            setTimeout(() => {
                button.textContent = originalText;
                button.style.color = '';
            }, 1000);
        }

        // Copy test name to clipboard
        function copyTestName(testPath) {
            const button = event.target;

            // Check if clipboard API is available (requires HTTPS or localhost)
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(testPath).then(() => {
                    showCopySuccess(button);
                }).catch(() => {
                    // Fallback for clipboard API errors
                    fallbackCopyToClipboard(testPath, button);
                });
            } else {
                // Fallback when clipboard API is not available (HTTP, older browsers)
                fallbackCopyToClipboard(testPath, button);
            }
        }

        // Fallback copy function for non-HTTPS environments
        function fallbackCopyToClipboard(text, button) {
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'fixed';
            textArea.style.left = '-999999px';
            textArea.style.top = '-999999px';
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();

            try {
                const successful = document.execCommand('copy');
                if (successful) {
                    showCopySuccess(button);
                } else {
                    console.log('Copy command returned false');
                }
            } catch (err) {
                console.error('Copy failed:', err);
            }

            document.body.removeChild(textArea);
        }

        // Render scatter plots for a test
        // Wait for Plotly to be available
        async function waitForPlotly() {
            if (typeof Plotly !== 'undefined') return;
            await new Promise(resolve => {
                const check = setInterval(() => {
                    if (typeof Plotly !== 'undefined') {
                        clearInterval(check);
                        resolve();
                    }
                }, 50);
            });
        }

        async function renderChart(testPath) {
            await waitForPlotly();

            const testData = aggregatedData[testPath];
            if (!testData) return;

            // Closure for plotly click handler - same function instance for both charts
            const plotlyClickHandler = function(data) {
                if (data.points.length > 0) {
                    const point = data.points[0];
                    const { taskIdString, jobName } = point.customdata;
                    const [taskId, retryId] = taskIdString.split('.');
                    const profileUrl = `https://firefox-ci-tc.services.mozilla.com/api/queue/v1/task/${taskId}/runs/${retryId}/artifacts/public/test_info/profile_resource-usage.json`;
                    const profileName = `${jobName} (${taskIdString})`;
                    const testName = testPath.split('/').pop();
                    const profilerUrl = `https://profiler.firefox.com/from-url/${encodeURIComponent(profileUrl)}?profileName=${encodeURIComponent(profileName)}&markerSearch=${encodeURIComponent(testName)}`;
                    window.open(profilerUrl, '_blank');
                }
            };

            const chartIdBase = testPath.replace(/[\/\.]/g, '-');
            const chartId = `chart-${chartIdBase}`;
            const timeoutChartId = `chart-timeout-${chartIdBase}`;
            const chartElement = document.getElementById(chartId);
            const timeoutChartElement = document.getElementById(timeoutChartId);
            if (!chartElement) return;

            // Platform colors (matching builds.html but with different Android color)
            const platformColors = {
                'android': '#8e44ad',       // Purple (instead of green to avoid "passing" implication)
                'linux': '#1f77b4',         // Blue
                'windows': '#ff7f0e',       // Orange
                'mac': '#9467bd',           // Purple
                'unknown': '#7f7f7f'        // Gray
            };

            const failureColor = '#d62728';  // Red for failures
            const timeoutColor = '#ff9800';  // Orange for timeouts

            // Prepare data for scatter plots
            const traces = {};
            const timeoutTraces = {};

            // Use lazy run creation for charts only
            const runs = getTestRuns(testPath);
            let hasTimeouts = false;

            runs.forEach((run, index) => {
                // Skip runs that are marked as skips
                if (run.isSkip) return;

                const platform = extractPlatform(run.jobName) || 'unknown';

                if (run.isTimeout) {
                    // Handle timeouts separately
                    hasTimeouts = true;
                    const traceKey = platform;

                    if (!timeoutTraces[traceKey]) {
                        timeoutTraces[traceKey] = {
                            x: [],
                            y: [],
                            mode: 'markers',
                            type: 'scatter',
                            name: `${platform} (timeout)`,
                            marker: {
                                color: platformColors[platform],
                                size: 8,
                                opacity: 0.7
                            },
                            customdata: [],
                            hovertemplate: '<b>%{customdata.jobName}</b><br>' +
                                           'Repository: %{customdata.repository}<br>' +
                                           'Status: TIMEOUT<br>' +
                                           'Duration: %{customdata.durationStr}<br>' +
                                           'Date: %{customdata.dateStr}<br>' +
                                           '<i>Click to view profile</i><br>' +
                                           '<extra></extra>'
                        };
                    }

                    timeoutTraces[traceKey].x.push(new Date(run.timestamp));
                    timeoutTraces[traceKey].y.push(run.duration / 1000); // Convert to seconds
                    timeoutTraces[traceKey].customdata.push({
                        repository: run.repository,
                        taskIdString: run.taskIdString,
                        jobName: run.jobName,
                        status: 'TIMEOUT',
                        durationStr: formatDurationMs(run.duration),
                        timestamp: run.timestamp,
                        dateStr: new Date(run.timestamp).toLocaleString()
                    });
                } else {
                    // Handle regular runs and failures
                    const isFail = run.isFail;
                    const traceKey = `${platform}-${isFail ? 'fail' : 'pass'}`;

                    if (!traces[traceKey]) {
                        const color = isFail ? failureColor : platformColors[platform];
                        const displayName = isFail ? `${platform} (failures)` : platform;

                        traces[traceKey] = {
                            x: [],
                            y: [],
                            mode: 'markers',
                            type: 'scatter',
                            name: displayName,
                            marker: {
                                color: color,
                                size: 8,
                                opacity: 0.7
                            },
                            customdata: [],
                            hovertemplate: '<b>%{customdata.jobName}</b><br>' +
                                           'Repository: %{customdata.repository}<br>' +
                                           'Status: %{customdata.status}<br>' +
                                           (isFail ? '%{customdata.details}<br>' : '') +
                                           'Duration: %{customdata.durationStr}<br>' +
                                           'Date: %{customdata.dateStr}<br>' +
                                           '<i>Click to view profile</i><br>' +
                                           '<extra></extra>'
                        };
                    }

                    traces[traceKey].x.push(new Date(run.timestamp));
                    traces[traceKey].y.push(run.duration / 1000); // Convert to seconds

                    // Build details string for failures (crash signature or failure message)
                    let details = '';
                    if (isFail) {
                        if (run.crashSignature) {
                            details = `Crash: ${run.crashSignature}`;
                        } else if (run.failureMessage) {
                            details = `Message: ${truncateMessage(run.failureMessage, 80)}`;
                        }
                    }

                    traces[traceKey].customdata.push({
                        repository: run.repository,
                        taskIdString: run.taskIdString,
                        jobName: run.jobName,
                        status: run.status || 'UNKNOWN',
                        details: details,
                        durationStr: formatDurationMs(run.duration),
                        timestamp: run.timestamp,
                        dateStr: new Date(run.timestamp).toLocaleString()
                    });
                }
            });

            // Update trace names with counts
            Object.keys(traces).forEach(traceKey => {
                const trace = traces[traceKey];
                const count = trace.x.length;
                if (count > 0) {
                    // Check if this is a failures trace by looking at the original name
                    const isFail = trace.name.includes('(failures)');
                    const platform = trace.name.replace(' (failures)', '');

                    if (isFail) {
                        trace.name = `${platform} (${count} failure${count !== 1 ? 's' : ''})`;
                    } else {
                        trace.name = `${platform} (${count} pass${count !== 1 ? 'es' : ''})`;
                    }
                }
            });

            // Render main chart (without timeouts)
            const layout = {
                title: `${testPath} - Run Times`,
                xaxis: {
                    title: 'Date',
                    type: 'date',
                    tickformat: '%Y-%m-%d'
                },
                yaxis: {
                    title: 'Duration (seconds)',
                    rangemode: 'tozero'
                },
                hoverlabel: {
                    font: { color: 'white' }
                },
                hovermode: 'closest',
                height: 400
            };

            const config = {
                responsive: true,
                displayModeBar: true
            };

            Plotly.newPlot(chartId, Object.values(traces), layout, config);

            // Add click handler to open profiles
            document.getElementById(chartId).on('plotly_click', plotlyClickHandler);

            // Render timeout chart only if there are timeouts
            if (hasTimeouts && timeoutChartElement) {
                // Update timeout trace names with counts
                Object.keys(timeoutTraces).forEach(traceKey => {
                    const trace = timeoutTraces[traceKey];
                    const count = trace.x.length;
                    if (count > 0) {
                        const platform = trace.name.replace(' (timeout)', '');
                        trace.name = `${platform} (${count} timeout${count !== 1 ? 's' : ''})`;
                    }
                });

                const timeoutLayout = {
                    title: `${testPath} - Timeouts`,
                    xaxis: {
                        title: 'Date',
                        type: 'date',
                        tickformat: '%Y-%m-%d'
                    },
                    yaxis: {
                        title: 'Duration (seconds)'
                        // Remove rangemode: 'tozero' to allow auto-scaling
                    },
                    hoverlabel: {
                        font: { color: 'white' }
                    },
                    hovermode: 'closest',
                    height: 300
                };

                Plotly.newPlot(timeoutChartId, Object.values(timeoutTraces), timeoutLayout, config);

                // Add click handler to open profiles for timeouts
                document.getElementById(timeoutChartId).on('plotly_click', plotlyClickHandler);
            }

            // Render crash chart if there are crashes
            const crashChartId = `chart-crash-${chartIdBase}`;
            const crashChartElement = document.getElementById(crashChartId);
            const crashTraces = {};
            let hasCrashes = false;

            runs.forEach(run => {
                if (run.status !== 'CRASH') return;

                hasCrashes = true;
                const platform = extractPlatform(run.jobName) || 'unknown';
                const traceKey = platform;

                if (!crashTraces[traceKey]) {
                    crashTraces[traceKey] = {
                        x: [],
                        y: [],
                        mode: 'markers',
                        type: 'scatter',
                        name: `${platform} (crash)`,
                        marker: {
                            color: platformColors[platform],
                            size: 8,
                            opacity: 0.7
                        },
                        customdata: [],
                        hovertemplate: '<b>%{customdata.jobName}</b><br>' +
                                       'Signature: %{customdata.signature}<br>' +
                                       'Repository: %{customdata.repository}<br>' +
                                       'Status: CRASH<br>' +
                                       'Duration: %{customdata.durationStr}<br>' +
                                       'Date: %{customdata.dateStr}<br>' +
                                       '<i>Click to view crash report</i><br>' +
                                       '<extra></extra>'
                    };
                }

                crashTraces[traceKey].x.push(new Date(run.timestamp));
                crashTraces[traceKey].y.push(run.duration / 1000);
                crashTraces[traceKey].customdata.push({
                    repository: run.repository,
                    taskIdString: run.taskIdString,
                    jobName: run.jobName,
                    signature: run.crashSignature || 'Unknown',
                    minidump: run.minidump,
                    durationStr: formatDurationMs(run.duration),
                    timestamp: run.timestamp,
                    dateStr: new Date(run.timestamp).toLocaleString()
                });
            });

            if (hasCrashes && crashChartElement) {
                // Update crash trace names with counts
                Object.keys(crashTraces).forEach(traceKey => {
                    const trace = crashTraces[traceKey];
                    const count = trace.x.length;
                    if (count > 0) {
                        const platform = trace.name.replace(' (crash)', '');
                        trace.name = `${platform} (${count} crash${count !== 1 ? 'es' : ''})`;
                    }
                });

                const crashLayout = {
                    title: `${testPath} - Crashes`,
                    xaxis: {
                        title: 'Date',
                        type: 'date',
                        tickformat: '%Y-%m-%d'
                    },
                    yaxis: {
                        title: 'Duration (seconds)'
                    },
                    hoverlabel: {
                        font: { color: 'white' }
                    },
                    hovermode: 'closest',
                    height: 300
                };

                Plotly.newPlot(crashChartId, Object.values(crashTraces), crashLayout, config);

                // Add click handler to open crash reports
                document.getElementById(crashChartId).on('plotly_click', function(data) {
                    if (data.points.length > 0) {
                        const point = data.points[0];
                        const minidump = point.customdata.minidump;
                        const { taskIdString } = point.customdata;
                        if (minidump && taskIdString) {
                            const [taskId, retryId] = taskIdString.split('.');
                            const jsonUrl = `https://firefox-ci-tc.services.mozilla.com/api/queue/v1/task/${taskId}/runs/${retryId}/artifacts/public/test_info/${minidump}.json`;
                            const crashUrl = `crash-viewer.html?url=${encodeURIComponent(jsonUrl)}`;
                            window.open(crashUrl, '_blank');
                        }
                    }
                });
            }
        }

        // Auto-expand folders that contain matching tests for a search term
        function autoExpandForSearch(searchTerm) {
            const lowerSearchTerm = searchTerm.toLowerCase();

            // Function to recursively expand folders with matches
            function expandMatchingFolders(node, currentPath = '') {
                // Check tests in this node
                for (const testName of Object.keys(node.tests)) {
                    const fullPath = currentPath ? `${currentPath}/${testName}` : testName;
                    if (fullPath.toLowerCase().includes(lowerSearchTerm)) {
                        // Expand all parent folders of this test
                        const parts = fullPath.split('/');
                        for (let i = 1; i < parts.length; i++) {
                            expandedRows.add(parts.slice(0, i).join('/'));
                        }
                    }
                }

                // Check child folders
                for (const childName of Object.keys(node.children)) {
                    const childPath = currentPath ? `${currentPath}/${childName}` : childName;
                    expandMatchingFolders(node.children[childName], childPath);
                }
            }

            if (treeData) {
                expandMatchingFolders(treeData);
            }
        }

        // Change view based on radio buttons
        function changeView() {
            const view = getCurrentView();

            // Update URL hash to reflect view change
            updateUrlHash();

            if (view === 'list') {
                renderListView();
            } else if (view === 'tree') {
                renderTree();
            } else {
                renderComponentsView();
            }
        }

        // Apply filtering to current view
        function applyFiltering() {
            const view = getCurrentView();
            const searchTerm = document.getElementById('search-box').value.toLowerCase().trim();

            if (view === 'list') {
                // List view filtering - re-render with filtered data
                renderListView();
            } else if (view === 'components') {
                // Components view filtering - re-render with filtered data
                renderComponentsView();
            } else {
                // Tree view filtering
                if (!searchTerm) {
                    // Clear search - collapse all
                    expandedRows.clear();
                    renderTree();
                    return;
                }

                // Auto-expand folders that contain matching tests
                expandedRows.clear();
                autoExpandForSearch(searchTerm);
                renderTree();
            }
        }

        // Load try revision data
        async function loadTryRevision(revision = null) {
            // If no revision provided, prompt for it
            if (!revision) {
                revision = prompt('Enter try revision hash:');
                if (!revision || !revision.trim()) return;
            }

            setStatusText('Loading try revision...');
            hideError();

            try {
                const file = `xpcshell-try-${revision}.json`;
                const response = await fetchData(file);

                if (!response.ok) {
                    throw new Error(`Try revision data not found. Run: node fetch-xpcshell-data.js --try ${revision}`);
                }

                currentData = await response.json();

                // Process raw data to create test entries and tree structure
                aggregatedData = createTestEntries();
                treeData = buildTreeStructure(aggregatedData);

                // Clear date selector and show revision info
                document.getElementById('date-select').value = '';
                const jobCount = currentData.metadata.jobCount || 0;
                setStatusText(`Try: ${revision.substring(0, 12)} (${jobCount.toLocaleString()} jobs)`);

                // Update URL to include try parameter
                const url = new URL(window.location);
                url.searchParams.set('try', revision);
                window.history.replaceState({}, '', url);

                // Render the view
                changeView();
            } catch (error) {
                showError(error.message);
                setStatusText('');
            }
        }

        // Load data from cache
        async function loadData() {
            setStatusText('Loading data...');
            hideError();

            try {
                const dateToLoad = document.getElementById('date-select').value;

                if (!dateToLoad) {
                    throw new Error('No date selected');
                }

                const file = `xpcshell-${dateToLoad}.json`;
                const response = await fetchData(file);

                if (!response.ok) {
                    throw new Error('No data available');
                }

                currentData = await response.json();

                // Show/hide components view radio based on data availability
                const componentsLabel = document.getElementById('components-view-label');
                if (hasComponentData()) {
                    componentsLabel.style.display = '';
                } else {
                    componentsLabel.style.display = 'none';
                    // If components was selected, switch to tree
                    const componentsRadio = document.getElementById('view-components');
                    if (componentsRadio.checked) {
                        document.getElementById('view-tree').checked = true;
                    }
                }

                // Process raw data to create test entries and tree structure
                aggregatedData = createTestEntries();
                treeData = buildTreeStructure(aggregatedData);

                // Update date selector and show job count
                if (currentData.metadata && currentData.metadata.date) {
                    updateDateSelector(currentData.metadata.date);
                    const jobCount = currentData.metadata.jobCount || 0;
                    setStatusText(`${jobCount.toLocaleString()} test jobs`);
                }

                changeView();
            } catch (error) {
                showError(`Error loading data: ${error.message}`, true);
            } finally {
                // Status text will show either job count (on success) or remain as loading (on error)
            }
        }

        // Update date selector
        function updateDateSelector(currentDate) {
            const select = document.getElementById('date-select');

            // Add current date if not already present
            const existingOption = Array.from(select.options).find(opt => opt.value === currentDate);
            if (!existingOption) {
                const option = document.createElement('option');
                option.value = currentDate;
                option.text = currentDate;
                option.selected = true;
                select.insertBefore(option, select.options[0]); // Insert at the beginning
            }
        }

        // Helper function to update clear button visibility (defined globally so it's accessible everywhere)
        function updateClearButton() {
            const searchBox = document.getElementById('search-box');
            const clearButton = document.getElementById('search-clear');
            clearButton.style.display = searchBox.value.trim() ? 'flex' : 'none';
        }

        // Populate date selector with available dates from index
        async function populateDateSelector() {
            const select = document.getElementById('date-select');

            try {
                const response = await fetchData('index.json');
                if (response.ok) {
                    const index = await response.json();

                    // Clear all existing options
                    select.innerHTML = '';

                    // Add all available dates
                    if (index.dates && index.dates.length > 0) {
                        index.dates.forEach((date, dateIndex) => {
                            const option = document.createElement('option');
                            option.value = date;
                            option.text = date;
                            option.selected = dateIndex === 0; // Select first (most recent) date
                            select.appendChild(option);
                        });

                        // After populating dropdown, restore state from URL hash
                        const hash = window.location.hash.slice(1);
                        if (hash) {
                            const params = new URLSearchParams(hash);

                            // Restore date selection
                            const urlDate = params.get('date');
                            if (urlDate && index.dates.includes(urlDate)) {
                                select.value = urlDate;
                            }

                            // Restore search filter
                            const search = params.get('q');
                            if (search) {
                                document.getElementById('search-box').value = search;
                                updateClearButton();
                            }

                            // Restore view selection (default to 'components' if not in hash)
                            const view = params.get('view') || 'components';
                            const radio = document.querySelector(`input[name="view-mode"][value="${view}"]`);
                            if (radio) radio.checked = true;
                        }
                    } else {
                        // No dates available
                        showError('No data available. Please run: node fetch-xpcshell-data.js', true);
                    }
                } else {
                    // Index file doesn't exist
                    showError('No data available. Please run: node fetch-xpcshell-data.js to fetch data.', true);
                }
            } catch (e) {
                console.warn('Could not load date index:', e);
                showError('Error loading data index. Please ensure data/index.json exists.', true);
            }
        }

        // Fetch new data by running the Node.js script
        async function fetchNewData() {
            showError('To fetch new data, run: node fetch-xpcshell-data.js');
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', async () => {
            // Get references to search elements
            const searchBox = document.getElementById('search-box');
            const clearButton = document.getElementById('search-clear');

            // Check URL parameters for try revision
            const urlParams = new URLSearchParams(window.location.search);
            const tryRevision = urlParams.get('try');

            if (tryRevision) {
                // Load try revision from URL
                await loadTryRevision(tryRevision);
            } else {
                // Populate date selector first
                await populateDateSelector();

                // Then load data only if we have dates
                // Set the hash first, which will trigger loadData via hashchange
                if (document.getElementById('date-select').value && !window.location.hash) {
                    updateUrlHash();
                } else if (document.getElementById('date-select').value) {
                    loadData();
                }
            }

            // Set up search box with debouncing
            let filterTimeout;

            searchBox.addEventListener('input', function(e) {
                // Update clear button visibility
                updateClearButton();

                // Clear previous timeout
                clearTimeout(filterTimeout);

                // Debounce both the filtering operation and hash update together
                filterTimeout = setTimeout(() => {
                    // Update hash first (with current search box value)
                    if (!isNavigating) {
                        updateUrlHash();
                    }
                    // Then do the expensive filtering
                    originalFilterTree();
                }, 300); // 300ms delay
            });

            // Clear button functionality
            clearButton.addEventListener('click', function() {
                searchBox.value = '';
                updateClearButton();
                clearTimeout(filterTimeout);
                applyFiltering(); // Clear filter immediately
                searchBox.focus(); // Keep focus on search box
            });

            function loadFromUrlHash() {
                const hash = window.location.hash.slice(1); // Remove #
                const params = new URLSearchParams(hash);

                // Restore date selection (or clear if not in hash)
                const date = params.get('date');
                document.getElementById('date-select').value = date || '';

                // Restore search filter (or clear if not in hash)
                // Don't update if the search box is currently focused (user is typing)
                const searchBox = document.getElementById('search-box');
                if (document.activeElement !== searchBox) {
                    const search = params.get('q');
                    searchBox.value = search || '';
                    updateClearButton();
                }

                // Restore view selection
                const availableViews = hasComponentData() ? ['components', 'tree', 'list'] : ['tree', 'list'];
                const requestedView = params.get('view');
                const view = availableViews.includes(requestedView) ? requestedView : availableViews[0];
                document.getElementById(`view-${view}`).checked = true;
            }

            // URL hash will be loaded after the date index is fetched

            // Update hash when date changes (modify existing loadData function)
            const originalOnChange = document.getElementById('date-select').onchange;
            document.getElementById('date-select').onchange = function() {
                updateUrlHash();
                if (originalOnChange) originalOnChange.call(this);
            };

            // Flag to prevent hash updates during navigation
            let isNavigating = false;

            // Store reference to filtering function (no wrapper needed since we handle hash in input handler)
            const originalFilterTree = applyFiltering;

            // Handle browser back/forward buttons
            window.addEventListener('hashchange', function() {
                isNavigating = true;
                loadFromUrlHash();

                if (document.getElementById('date-select').value) {
                    loadData(); // This will also call filtering after loading data
                } else {
                    applyFiltering(); // Update view with current filter state
                }

                isNavigating = false;
            });
        });
    </script>
    <script async src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
</body>
</html>
