<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test Issues</title>
    <script src="fetch-utils.js"></script>
    <script defer src="shared.js"></script>
    <link rel="stylesheet" href="shared.css">
    <style>
        .tree-table {
            width: 100%;
            background: white;
            border-radius: 8px;
            overflow: hidden;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .tree-row {
            border-bottom: 1px solid #eee;
            cursor: pointer;
            transition: background-color 0.2s;
            display: flex;
            align-items: center;
            padding: 4px 10px;
            min-height: 28px; /* Ensure consistent height even when empty */
        }

        .tree-row:hover {
            background-color: #f5f5f5;
        }

        .tree-row.expanded {
            background-color: #f0f8ff;
        }

        .tree-name {
            flex: 1;
            font-family: monospace;
            font-size: 13px;
        }

        .tree-stats {
            display: flex;
            gap: 30px;
            font-size: 13px;
        }

        .stat-item {
            display: flex;
            flex-direction: column;
            align-items: flex-end;
            text-align: right;
            min-width: 60px;
        }

        /* Reduce opacity for zero-valued stats that are hideable */
        .stat-item.hideable-zero {
            opacity: 0.15;
            transition: opacity 0.2s ease;
        }

        /* Show all stats on row hover */
        .tree-row:hover .stat-item.hideable-zero {
            opacity: 1;
        }

        /* Non-clickable rows (components with no issues) shouldn't show pointer cursor */
        .tree-row.non-clickable {
            cursor: default;
        }

        .stat-label {
            color: #666;
            font-size: 11px;
            text-transform: uppercase;
        }

        .stat-value {
            font-weight: bold;
            color: #333;
        }

        .stat-value.fail {
            color: #d00;
        }

        .stat-value.orange {
            color: #ff8c00;
        }

        .stat-value.yellow {
            color: #c9a500;
        }

        .stat-value.skip, .stat-value.zero {
            color: #888;
        }

        .stat-value.timeout {
            color: #f60;
        }

        .folder-icon, .test-icon {
            margin-right: 5px;
        }

        .folder-icon::before {
            content: "üß© ";
        }

        .test-icon::before {
            content: "üìÑ ";
        }

        .tree-indent {
            display: inline-block;
            width: 20px;
        }

        .controls {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 20px;
            gap: 20px;
        }

        .search-container {
            position: relative;
            display: inline-block;
        }

        .search-box {
            padding: 8px 30px 8px 12px;
            width: 300px;
            box-sizing: border-box;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-size: 14px;
            flex-shrink: 0;
        }

        .search-clear {
            position: absolute;
            right: 8px;
            top: 50%;
            transform: translateY(-50%);
            background: none;
            border: none;
            cursor: pointer;
            font-size: 16px;
            color: #999;
            padding: 0;
            width: 20px;
            height: 20px;
            display: none;
            align-items: center;
            justify-content: center;
        }

        .search-clear:hover {
            color: #666;
        }

        .date-selector {
            display: flex;
            align-items: center;
            gap: 10px;
            flex-shrink: 0;
        }

        .status-text {
            font-size: 14px;
            color: #666;
            margin: 0;
            padding: 0;
            vertical-align: baseline;
        }

        .historical-button {
            margin-left: 15px;
            padding: 6px 12px;
            background-color: #007bff;
            color: white;
            border: none;
            border-radius: 4px;
            font-size: 14px;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .historical-button:hover {
            background-color: #0056b3;
        }

        .historical-button.active {
            background-color: #28a745;
        }

        .historical-button.active:hover {
            background-color: #1e7e34;
        }

        .explanation {
            background-color: #f8f9fa;
            border: 1px solid #dee2e6;
            border-radius: 4px;
            padding: 15px 20px;
            margin: 15px 0;
            font-size: 14px;
            line-height: 1.6;
            color: #333;
        }

        .explanation strong {
            color: #000;
        }

        .explanation ul {
            margin: 8px 0;
            padding-left: 25px;
        }

        .explanation li {
            margin: 4px 0;
        }

        .explanation code {
            background-color: #e9ecef;
            padding: 2px 5px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 13px;
        }

        .no-data {
            padding: 40px;
            text-align: center;
            color: #666;
            background: white;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        .sort-header {
            background: #f8f9fa;
            border-bottom: 2px solid #ddd;
            padding: 0 10px;
            display: flex;
            align-items: center;
            font-weight: bold;
            position: sticky;
            top: 0;
            z-index: 10;
        }

        .sort-header .tree-stats {
            gap: 30px; /* Match the gap from regular tree-stats */
        }

        .sort-header .tree-name {
            color: #666;
        }

        .sort-button {
            background: none;
            border: none;
            cursor: pointer;
            padding: 10px;
            margin: 0 -10px;
            font-size: 11px;
            text-transform: uppercase;
            color: #666;
            border-radius: 3px;
            transition: background-color 0.2s;
            display: flex;
            align-items: center;
            justify-content: flex-end;
            text-align: right;
            width: 100%;
            white-space: nowrap;
        }

        .sort-button:hover {
            background-color: #e9ecef;
        }

        .sort-button.active {
            color: #007bff;
            background-color: #e7f3ff;
        }

        .sort-arrow {
            font-size: 10px;
            margin-right: 2px;
            width: 8px;
            display: inline-block;
            text-align: left;
        }

        .tooltip {
            position: relative;
            cursor: help;
        }

        .tooltip .tooltiptext {
            visibility: hidden;
            width: 200px;
            background-color: #2a2a2a;
            color: white;
            text-align: left;
            border-radius: 6px;
            padding: 8px;
            position: absolute;
            z-index: 1000;
            bottom: 125%;
            right: 0;
            opacity: 0;
            transition: opacity 0.3s;
            font-size: 12px;
            line-height: 1.4;
            box-shadow: 0 2px 8px rgba(0,0,0,0.3);
        }

        .tooltip .tooltiptext::after {
            content: "";
            position: absolute;
            top: 100%;
            right: 20px;
            border-width: 5px;
            border-style: solid;
            border-color: #2a2a2a transparent transparent transparent;
        }

        .tooltip:hover .tooltiptext {
            visibility: visible;
            opacity: 1;
        }

        .tooltip-platform {
            display: flex;
            justify-content: space-between;
            margin: 2px 0;
        }

        .tooltip-platform-name {
            font-weight: bold;
        }

        .total-row {
            background-color: #f8f9fa;
            border-bottom: 2px solid #ddd;
            font-weight: bold;
        }

        .total-row:hover {
            background-color: #f8f9fa;
        }

        .total-row .tree-name {
            color: #495057;
        }

        .lazy-row .loading {
            color: #999;
            font-style: italic;
        }

        .dynamic-tooltip {
            position: absolute;
            background: #333;
            color: white;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            white-space: nowrap;
            z-index: 1000;
            pointer-events: none;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }

        .action-button {
            background: none;
            border: none;
            cursor: pointer;
            padding: 2px 4px;
            margin-left: 6px;
            font-size: 11px;
            color: #666;
            border-radius: 3px;
            transition: background-color 0.2s;
            opacity: 0;
            vertical-align: middle;
            text-decoration: none;
            display: inline-block;
        }

        .tree-row:hover .action-button,
        .folder-row:hover .action-button {
            opacity: 1;
        }

        .action-button:hover {
            background-color: #e9ecef;
            color: #333;
        }

        .action-button:active {
            background-color: #007bff;
            color: white;
        }

        /* Issue details styles */
        .issue-details-row {
            background-color: #f8f9fa;
            border-bottom: 1px solid #eee;
            padding: 15px 20px;
        }

        .issue-details-content {
            font-family: monospace;
            font-size: 12px;
        }

        .issue-section {
            margin-bottom: 20px;
        }

        .issue-section:last-child {
            margin-bottom: 0;
        }

        .issue-section h4 {
            margin: 0 0 10px 0;
            font-size: 13px;
            color: #333;
            font-weight: bold;
        }

        .issue-item {
            display: flex;
            align-items: flex-start;
            padding: 5px 0;
            border-bottom: 1px solid #e9ecef;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .issue-item:hover {
            background-color: #e9ecef;
        }

        .issue-item:last-child {
            border-bottom: none;
        }

        .issue-runs {
            margin-left: 50px;
            margin-top: 8px;
            margin-bottom: 8px;
            font-size: 11px;
            color: #666;
        }

        .issue-run-item {
            padding: 3px 0;
        }

        .issue-run-item a {
            color: #007bff;
            text-decoration: none;
        }

        .issue-run-item a:hover {
            text-decoration: underline;
        }

        .issue-count {
            font-weight: bold;
            margin-right: 10px;
            min-width: 30px;
            text-align: right;
            flex-shrink: 0;
            color: #333;
        }

        .issue-badge {
            padding: 2px 6px;
            border-radius: 3px;
            font-size: 10px;
            font-weight: bold;
            margin-right: 10px;
            flex-shrink: 0;
            text-transform: uppercase;
        }

        .badge-skip {
            background-color: #6c757d;
            color: #fff;
        }

        .badge-fail {
            background-color: #ff8c00;
            color: #fff;
        }

        .badge-crash {
            background-color: #dc3545;
            color: #fff;
        }

        .badge-timeout {
            background-color: #ffc107;
            color: #000;
        }

        .issue-message {
            flex: 1;
            color: #333;
            line-height: 1.4;
            word-break: break-word;
        }

        /* Chart styles */
        .historical-chart {
            margin: 0;
            padding: 0;
        }

        .issue-details-content > .historical-chart {
            margin-left: 20px;
        }

        .historical-chart h5 {
            margin: 0 0 10px 0;
            font-size: 14px;
            color: #333;
            font-weight: bold;
        }

        .historical-chart-canvas {
            max-height: 100px;
            height: 100px;
            width: 100%;
        }

        .historical-chart-canvas[id$="-skips-canvas"] {
            max-height: 70px;
            height: 70px;
        }

        .historical-chart-canvas.no-x-axis {
            max-height: 60px;
            height: 60px;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Test Issues</h1>

        <div class="controls">
            <div class="date-selector">
                <label for="date-select">Select Date: </label>
                <select id="date-select" onchange="loadData()">
                </select>
                <span id="status-text" class="status-text">Loading data...</span>
                <button id="historical-button" class="historical-button" onclick="toggleHistoricalData()">Show Last 21 Days</button>
            </div>
            <div class="search-container">
                <input type="text" class="search-box" id="search-box" placeholder="Search for test paths or components...">
                <button class="search-clear" id="search-clear" title="Clear search">√ó</button>
            </div>
        </div>

        <div class="explanation">
            <strong>Issues</strong> include:
            <ul>
                <li><strong>Failures:</strong> Tests that ran but failed</li>
                <li><strong>Timeouts:</strong> Tests that exceeded their time limit and didn't finish</li>
                <li><strong>Crashes:</strong> Tests that caused a process to crash</li>
                <li><strong>Skips (<code>skip-if</code>):</strong> Tests that didn't run because they are known to be unreliable on some platforms or configurations.<br><strong>Note:</strong> Tests annotated with <code>run-if</code> are explicitly platform-specific and are not considered issues when they don't run on other platforms.</li>
            </ul>
        </div>

        <div id="error" class="error" style="display: none;"></div>

        <div id="tree-container" style="display: none;">
            <div class="tree-table" id="tree-table"></div>
        </div>

        <div id="no-data" class="no-data" style="display: none;">
            No data available. Click "Fetch New Data" to fetch xpcshell test data.
        </div>
    </div>

    <script>
        let currentData = null;
        let aggregatedData = null;
        let treeData = null;
        let expandedRows = new Set();
        let sortField = 'issueCount';
        let sortDirection = 'desc'; // Start with descending for failure count (most failing first)
        let isNavigating = false; // Flag to prevent hash updates during navigation
        let isHistoricalMode = false; // Flag to track if we're showing historical data
        let historicalData = null; // Store the loaded historical data
        let detailedData = null; // Store detailed data (with taskIds) when loaded
        let isLoadingDetailedData = false; // Flag to prevent duplicate fetches

        // Placeholder message for failures without recorded details (e.g., Android logging issues)
        const FAILURE_NO_MESSAGE = 'Failure details not recorded (likely Android or platform logging issue)';

        // Format duration in milliseconds to human readable
        function formatDurationMs(ms, hasData = true) {
            if (!hasData || ms === 0) {
                return '‚Äî';  // Em dash for no data
            }
            if (ms < 1000) {
                return `${Math.round(ms)}ms`;
            } else if (ms < 60000) {
                return `${(ms / 1000).toFixed(1)}s`;
            } else if (ms < 3600000) {  // Less than 1 hour
                const minutes = Math.floor(ms / 60000);
                const seconds = Math.floor((ms % 60000) / 1000);
                if (seconds === 0) {
                    return `${minutes}m`;
                }
                return `${minutes}m ${seconds}s`;
            } else if (ms < 86400000) {  // Less than 1 day
                const hours = Math.floor(ms / 3600000);
                const minutes = Math.floor((ms % 3600000) / 60000);
                if (minutes === 0) {
                    return `${hours}h`;
                }
                return `${hours}h ${minutes}m`;
            } else {  // Days
                const days = Math.floor(ms / 86400000);
                const hours = Math.floor((ms % 86400000) / 3600000);
                if (hours === 0) {
                    return `${days}d`;
                }
                return `${days}d ${hours}h`;
            }
        }


        // Format numbers with thousand separators
        function formatNumber(num) {
            return num.toLocaleString();
        }

        // Escape HTML to prevent XSS
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Get CSS class and display value for issue percentage
        function getIssuePercentageDisplay(issueCount, totalCount) {
            if (totalCount === 0) {
                return { displayValue: '0%', cssClass: 'zero' };
            }

            const exactPercentage = (issueCount / totalCount) * 100;

            if (exactPercentage === 0) {
                return { displayValue: '0%', cssClass: 'zero' };
            } else if (exactPercentage < 1) {
                return { displayValue: '<1%', cssClass: '' }; // Black (no special class)
            } else {
                const roundedPercentage = Math.round(exactPercentage);
                let cssClass;
                if (roundedPercentage >= 20) {
                    cssClass = 'fail'; // Red
                } else if (roundedPercentage >= 10) {
                    cssClass = 'orange';
                } else if (roundedPercentage > 1) {
                    cssClass = 'yellow';
                } else {
                    cssClass = ''; // Black (shouldn't reach here, but just in case)
                }
                return { displayValue: `${roundedPercentage}%`, cssClass };
            }
        }

        // Generate individual stat item HTML
        function generateStatItem(label, value, valueCssClass = '', containerClass = '', title = '', extraAttrs = '') {
            const titleAttr = title ? ` title="${title}"` : '';
            const containerClassAttr = containerClass ? ` class="stat-item ${containerClass}"` : ' class="stat-item"';
            const valueClassAttr = valueCssClass ? ` class="stat-value ${valueCssClass}"` : ' class="stat-value"';
            return `<div${containerClassAttr}${titleAttr}${extraAttrs}><span class="stat-label">${label}</span><span${valueClassAttr}>${value}</span></div>`;
        }

        // Generate stats HTML for a test (shared between tree and list views)
        function generateStatsHtml(stats, testPath, hasRuns) {
            let html = '';
            html += generateStatItem('Runs', formatNumber(stats.runCount), stats.runCount === 0 ? 'fail' : '');

            const issuePercentageDisplay = getIssuePercentageDisplay(stats.issueCount, stats.runCount + stats.skipCount);
            html += generateStatItem('Issue %', issuePercentageDisplay.displayValue, issuePercentageDisplay.cssClass);

            const issueClass = stats.issueCount > 0 ? 'fail' : 'zero';
            const issueContainerClass = stats.issueCount === 0 ? 'hideable-zero' : '';
            html += generateStatItem('Issues', formatNumber(stats.issueCount), issueClass, issueContainerClass);

            const skipContainerClass = stats.skipCount === 0 ? 'hideable-zero' : (stats.skipCount > 0 ? 'lazy-tooltip' : '');
            html += generateStatItem('Skips', formatNumber(stats.skipCount), 'skip', skipContainerClass, '', stats.skipCount > 0 ? ` data-test-path="${testPath}" data-tooltip-type="skips"` : '');

            const failClass = stats.failCount > 0 ? 'fail' : 'zero';
            const failContainerClass = stats.failCount === 0 ? 'hideable-zero' : (stats.failCount > 0 ? 'lazy-tooltip' : '');
            html += generateStatItem('Failures', formatNumber(stats.failCount), failClass, failContainerClass, '', stats.failCount > 0 ? ` data-test-path="${testPath}" data-tooltip-type="failures"` : '');

            const timeoutClass = stats.timeoutCount > 0 ? 'timeout' : 'zero';
            const timeoutContainerClass = stats.timeoutCount === 0 ? 'hideable-zero' : (stats.timeoutCount > 0 ? 'lazy-tooltip' : '');
            html += generateStatItem('Timeouts', formatNumber(stats.timeoutCount), timeoutClass, timeoutContainerClass, '', stats.timeoutCount > 0 ? ` data-test-path="${testPath}" data-tooltip-type="timeouts"` : '');

            const crashClass = stats.crashCount > 0 ? 'fail' : 'zero';
            const crashContainerClass = stats.crashCount === 0 ? 'hideable-zero' : '';
            html += generateStatItem('Crashes', formatNumber(stats.crashCount), crashClass, crashContainerClass, '', stats.crashCount > 0 ? ` data-test-path="${testPath}" data-tooltip-type="crashes"` : '');

            return html;
        }

        // Generate copy button for test paths
        function generateCopyButton(testPath) {
            return `<button class="action-button" onclick="copyTestName('${testPath}'); event.stopPropagation();" title="Copy test path">üìã</button>`;
        }

        // Generate Searchfox button for test paths
        function generateSearchfoxButton(testPath) {
            const searchfoxUrl = `https://searchfox.org/mozilla-central/source/${testPath}`;
            return `<a href="${searchfoxUrl}" class="action-button" target="_blank" onclick="event.stopPropagation();" title="Open in Searchfox">üîç</a>`;
        }

        // Generate both copy and Searchfox buttons for test paths
        function generateTestButtons(testPath) {
            return generateCopyButton(testPath) + generateSearchfoxButton(testPath);
        }

        // Generate Searchfox button for folder paths
        function generateFolderButtons(folderPath) {
            const searchfoxUrl = `https://searchfox.org/mozilla-central/source/${folderPath}`;
            return `<a href="${searchfoxUrl}" class="action-button" target="_blank" onclick="event.stopPropagation();" title="Open folder in Searchfox">üîç</a>`;
        }

        // Error display management (shared across all error scenarios)
        function showError(message, showNoData = false) {
            const errorElement = document.getElementById('error');
            errorElement.style.display = 'block';
            errorElement.textContent = message;

            if (showNoData) {
                document.getElementById('no-data').style.display = 'block';
            }
        }

        function hideError() {
            document.getElementById('error').style.display = 'none';
            document.getElementById('no-data').style.display = 'none';
        }

        // Status text management (shared for loading states)
        function setStatusText(text) {
            document.getElementById('status-text').textContent = text;
        }

        // URL hash management
        // Helper to get current view mode
        function getCurrentView() {
            // Always use components view for issues page
            return 'components';
        }

        function updateUrlHash() {
            const date = isHistoricalMode ? '21days' : document.getElementById('date-select').value;
            const search = document.getElementById('search-box').value.trim();
            const view = getCurrentView();

            const params = new URLSearchParams();
            if (date) params.set('date', date);
            if (search) params.set('q', search);
            // Only add view to URL if not the default
            if (view !== 'components') params.set('view', view);

            const hash = params.toString();
            if (hash) {
                window.location.hash = hash;
            } else {
                // Preserve search parameters when clearing hash
                const url = window.location.pathname + window.location.search;
                history.replaceState(null, '', url);
            }
        }

        // Create test data entries with only testIds - everything computed from global currentData
        function createTestEntries() {
            const testEntries = {};

            if (!currentData.testRuns || !currentData.tables || !currentData.testInfo) {
                return testEntries;
            }

            // Create minimal entries for each test with only testId
            for (let testId = 0; testId < currentData.testRuns.length; testId++) {
                const testGroup = currentData.testRuns[testId];
                if (!testGroup) continue;

                const testPath = currentData.tables.testPaths[currentData.testInfo.testPathIds[testId]];
                const testName = currentData.tables.testNames[currentData.testInfo.testNameIds[testId]];
                const fullPath = testPath ? `${testPath}/${testName}` : testName;

                // Get component if available
                const componentId = currentData.testInfo.componentIds ? currentData.testInfo.componentIds[testId] : null;
                const component = (componentId !== null && currentData.tables.components) ? currentData.tables.components[componentId] : null;

                testEntries[fullPath] = {
                    testId: testId,
                    component: component
                };
            }

            return testEntries;
        }

        // Compute statistics for a single test from global currentData
        function computeTestStats(testId) {
            const testGroup = currentData.testRuns[testId];

            if (!testGroup) {
                return {
                    runCount: 0,
                    skipCount: 0,
                    passCount: 0,
                    failCount: 0,
                    timeoutCount: 0,
                    crashCount: 0,
                    issueCount: 0,
                    issuePercentage: 0,
                    max: 0,
                    min: 0,
                    avg: 0
                };
            }

            let skipCount = 0;
            let timeoutCount = 0;
            let failCount = 0;
            let crashCount = 0;
            let passCount = 0;
            let parallelFailCount = 0;
            let parallelPassCount = 0;
            let parallelTimeoutCount = 0;
            let sequentialPassCount = 0;
            let sequentialFailCount = 0;
            let sequentialTimeoutCount = 0;

            // Process each status group within this test
            for (let statusId = 0; statusId < testGroup.length; statusId++) {
                const statusGroup = testGroup[statusId];
                if (!statusGroup) continue;

                const status = currentData.tables.statuses[statusId];

                // Check if this is aggregated format (passing runs) or detailed format
                const isAggregatedFormat = statusGroup.counts !== undefined && statusGroup.timeBuckets !== undefined;
                const runCount = isAggregatedFormat
                    ? statusGroup.counts.reduce((sum, count) => sum + count, 0)
                    : statusGroup.taskIdIds.length;

                const isSkip = status === 'SKIP';
                const isCrash = status === 'CRASH';
                const isTimeout = status === 'TIMEOUT' || status === 'TIMEOUT-PARALLEL' || status === 'TIMEOUT-SEQUENTIAL';
                const isFail = status && !['PASS', 'PASS-PARALLEL', 'PASS-SEQUENTIAL', 'SKIP', 'CRASH', 'TIMEOUT', 'TIMEOUT-PARALLEL', 'TIMEOUT-SEQUENTIAL', 'EXPECTED-FAIL'].includes(status);

                // Add counts for this status group
                if (isSkip) {
                    // Only count as skip if the message doesn't start with "run-if"
                    // (run-if indicates platform-specific tests, not actual skips due to broken tests)
                    if (statusGroup.messageIds) {
                        if (isAggregatedFormat) {
                            // In aggregated format, messageIds is parallel to counts
                            for (let i = 0; i < statusGroup.messageIds.length; i++) {
                                const messageId = statusGroup.messageIds[i];
                                const message = messageId !== null ? currentData.tables.messages[messageId] : null;
                                // Count as skip if there's no message or if it doesn't start with run-if
                                if (!message || !message.startsWith('run-if')) {
                                    skipCount += statusGroup.counts[i];
                                }
                                // run-if skips are not counted (platform-specific tests that are irrelevant on this platform)
                            }
                        } else {
                            // In detailed format, iterate through messageIds
                            for (const messageId of statusGroup.messageIds) {
                                const message = messageId !== null ? currentData.tables.messages[messageId] : null;
                                // Count as skip if there's no message or if it doesn't start with run-if
                                if (!message || !message.startsWith('run-if')) {
                                    skipCount++;
                                }
                                // run-if skips are not counted (platform-specific tests that are irrelevant on this platform)
                            }
                        }
                    } else {
                        // If there are no message IDs, count all as skips
                        skipCount += runCount;
                    }
                } else if (status === 'TIMEOUT-PARALLEL') {
                    timeoutCount += runCount;
                    parallelTimeoutCount += runCount;
                } else if (status === 'TIMEOUT-SEQUENTIAL') {
                    timeoutCount += runCount;
                    sequentialTimeoutCount += runCount;
                } else if (isTimeout) {
                    // Old TIMEOUT without parallel/sequential designation
                    timeoutCount += runCount;
                } else if (isCrash) {
                    crashCount += runCount;
                } else if (status === 'UNKNOWN') {
                    // For UNKNOWN status, check durations only if available (not aggregated)
                    // Otherwise just count as passes
                    if (!isAggregatedFormat && statusGroup.durations) {
                        for (const duration of statusGroup.durations) {
                            if (duration < 100) {
                                skipCount++;
                            } else if (duration > 300000) {
                                timeoutCount++;
                            } else {
                                passCount++;
                            }
                        }
                    } else {
                        passCount += runCount;
                    }
                } else if (status === 'FAIL-PARALLEL') {
                    failCount += runCount;
                    parallelFailCount += runCount;
                } else if (status === 'FAIL-SEQUENTIAL') {
                    failCount += runCount;
                    sequentialFailCount += runCount;
                } else if (status === 'PASS-PARALLEL') {
                    passCount += runCount;
                    parallelPassCount += runCount;
                } else if (status === 'PASS-SEQUENTIAL') {
                    passCount += runCount;
                    sequentialPassCount += runCount;
                } else if (isFail) {
                    failCount += runCount;
                } else {
                    // PASS or EXPECTED-FAIL (or old PASS without parallel/sequential designation)
                    passCount += runCount;
                }
            }

            const runCount = skipCount + timeoutCount + failCount + crashCount + passCount - skipCount; // Total minus skips

            // Calculate parallel failure rate correctly:
            // This is the percentage of parallel runs that failed or timed out
            const parallelTotalRuns = parallelFailCount + parallelTimeoutCount + parallelPassCount;
            const parallelProblematicCount = parallelFailCount + parallelTimeoutCount;
            const parallelFailPercentage = parallelTotalRuns > 0
                ? Math.round((parallelProblematicCount * 100) / parallelTotalRuns)
                : 0;

            return {
                runCount: runCount,
                skipCount: skipCount,
                passCount: passCount,
                timeoutCount: timeoutCount,
                failCount: failCount,
                crashCount: crashCount,
                issueCount: skipCount + failCount + timeoutCount + crashCount,
                parallelFailCount: parallelFailCount,
                parallelTimeoutCount: parallelTimeoutCount,
                parallelPassCount: parallelPassCount,
                sequentialPassCount: sequentialPassCount,
                sequentialFailCount: sequentialFailCount,
                sequentialTimeoutCount: sequentialTimeoutCount,
                parallelFailPercentage: parallelFailPercentage,
                issuePercentage: (runCount + skipCount) > 0 ? ((skipCount + failCount + timeoutCount + crashCount) / (runCount + skipCount) * 100) : 0
            };
        }

        // Build tree structure from test entries, computing statistics directly from raw data
        function buildTreeStructure(testEntries) {
            const tree = {
                name: 'root',
                path: '',
                children: {},
                tests: {}
            };

            for (const testPath in testEntries) {
                const parts = testPath.split('/');
                let currentNode = tree;

                // Navigate/create folder structure
                for (let i = 0; i < parts.length - 1; i++) {
                    const folder = parts[i];

                    if (!currentNode.children[folder]) {
                        currentNode.children[folder] = {
                            name: folder,
                            path: parts.slice(0, i + 1).join('/'),
                            children: {},
                            tests: {}
                        };
                    }

                    currentNode = currentNode.children[folder];
                }

                // Compute test statistics from global currentData
                const testData = testEntries[testPath];
                const testStats = computeTestStats(testData.testId);

                // Add computed stats to test data
                testData.stats = testStats;

                // Add test to the final folder
                const testName = parts[parts.length - 1];
                currentNode.tests[testName] = {
                    name: testName,
                    path: testPath,
                    data: testData
                };
            }

            return tree;
        }

        // Build sort header
        function buildSortHeader() {
            const getSortButton = ([field, label]) => {
                const isActive = sortField === field;
                const arrow = isActive ? (sortDirection === 'asc' ? '‚Üë' : '‚Üì') : ' '; // Always show space
                return `<div class="stat-item">
                    <button class="sort-button ${isActive ? 'active' : ''}" data-field="${field}" onclick="changeSortOrder('${field}')">
                        <span class="sort-arrow">${arrow}</span>${label}
                    </button>
                </div>`;
            };

            // Check if we're in list/components view or if we have tests to show appropriate headers
            const view = getCurrentView();
            const isListLike = view === 'list' || view === 'components';
            const hasTests = isListLike || (treeData && Object.values(treeData.children).some(folder => Object.keys(folder.tests).length > 0));

            // Special button for Path (left-aligned)
            const getPathButton = (field, label) => {
                const isActive = sortField === field;
                const arrow = isActive ? (sortDirection === 'asc' ? '‚Üë' : '‚Üì') : ' '; // Always show space
                return `<button class="sort-button ${isActive ? 'active' : ''}" data-field="${field}" onclick="changeSortOrder('${field}')" style="justify-content: flex-start;">
                    <span class="sort-arrow">${arrow}</span>${label}
                </button>`;
            };

            // Generate appropriate stats buttons based on view type
            const statsFields = [['runCount', 'Runs'], ['issuePercentage', 'Issue %'], ['issueCount', 'Issues'], ['skipCount', 'Skips'], ['failCount', 'Failures'], ['timeoutCount', 'Timeouts'], ['crashCount', 'Crashes']];

            const statsButtons = statsFields.map(getSortButton).join('');

            return `<div class="sort-header">
                <div class="tree-name">${getPathButton('name', 'Component / Test')}</div>
                <div class="tree-stats">
                    ${statsButtons}
                </div>
            </div>`;
        }

        // Change sort order
        function changeSortOrder(field) {
            if (sortField === field) {
                sortDirection = sortDirection === 'asc' ? 'desc' : 'asc';
            } else {
                sortField = field;
                // Default to descending for most fields, ascending for path and pass percentage
                if (field === 'name' || field === 'issuePercentage') {
                    sortDirection = 'asc';
                } else {
                    sortDirection = 'desc';
                }
            }
            changeView();
        }

        // Calculate parallel platform breakdown for test data
        function calculateParallelPlatformBreakdown(testData) {
            const platforms = {};

            if (currentData && currentData.testRuns && testData.testId !== undefined) {
                const testGroup = currentData.testRuns[testData.testId];
                if (testGroup) {
                    for (let statusId = 0; statusId < testGroup.length; statusId++) {
                        const statusGroup = testGroup[statusId];
                        if (!statusGroup) continue;

                        const status = currentData.tables.statuses[statusId];

                        // Only count parallel statuses
                        if (!status || !status.includes('PARALLEL')) continue;

                        // Skip if no taskIdIds (aggregated format)
                        if (!statusGroup.taskIdIds) continue;

                        for (let i = 0; i < statusGroup.taskIdIds.length; i++) {
                            const taskIdIndex = statusGroup.taskIdIds[i];
                            const jobName = currentData.tables.jobNames[currentData.taskInfo.jobNameIds[taskIdIndex]];
                            const platform = extractPlatform(jobName) || 'unknown';

                            if (!platforms[platform]) {
                                platforms[platform] = {
                                    parallelFails: 0,
                                    parallelTimeouts: 0,
                                    parallelPasses: 0
                                };
                            }

                            if (status === 'FAIL-PARALLEL') {
                                platforms[platform].parallelFails++;
                            } else if (status === 'TIMEOUT-PARALLEL') {
                                platforms[platform].parallelTimeouts++;
                            } else if (status === 'PASS-PARALLEL') {
                                platforms[platform].parallelPasses++;
                            }
                        }
                    }
                }
            }

            return platforms;
        }

        // Calculate platform timing breakdown for test data
        function calculateTestPlatformTimingBreakdown(testData) {
            const platforms = {};

            // Use global currentData to avoid creating run objects just for tooltips
            if (testData.testId !== undefined) {
                const testGroup = currentData.testRuns[testData.testId];

                if (testGroup) {
                    // Process each status group
                    for (let statusId = 0; statusId < testGroup.length; statusId++) {
                        const statusGroup = testGroup[statusId];
                        if (!statusGroup) continue;

                        const status = currentData.tables.statuses[statusId];
                        const isPass = status === 'PASS' || status === 'PASS-PARALLEL' || status === 'PASS-SEQUENTIAL';

                        // Only track timing for passing tests
                        if (isPass && statusGroup.taskIdIds) {
                            for (let i = 0; i < statusGroup.taskIdIds.length; i++) {
                                const taskIdIndex = statusGroup.taskIdIds[i];
                                const jobName = currentData.tables.jobNames[currentData.taskInfo.jobNameIds[taskIdIndex]];
                                const platform = extractPlatform(jobName) || 'unknown';
                                const duration = statusGroup.durations[i];

                                if (!platforms[platform]) {
                                    platforms[platform] = {
                                        durations: [],
                                        min: Infinity,
                                        max: 0,
                                        total: 0,
                                        count: 0
                                    };
                                }

                                platforms[platform].durations.push(duration);
                                platforms[platform].total += duration;
                                platforms[platform].count++;
                                platforms[platform].min = Math.min(platforms[platform].min, duration);
                                platforms[platform].max = Math.max(platforms[platform].max, duration);
                            }
                        }
                    }
                }

                // Calculate averages and handle edge cases
                Object.keys(platforms).forEach(platform => {
                    const p = platforms[platform];
                    p.avg = p.count > 0 ? p.total / p.count : 0;
                    if (p.min === Infinity) p.min = 0;
                });
            }

            return platforms;
        }

        // Calculate platform breakdown for test data
        function calculateTestPlatformBreakdown(testData) {
            const platforms = {};

            // Use global currentData to avoid creating run objects just for tooltips
            if (testData.testId !== undefined) {
                const testGroup = currentData.testRuns[testData.testId];

                if (testGroup) {
                    // Process each status group
                    for (let statusId = 0; statusId < testGroup.length; statusId++) {
                        const statusGroup = testGroup[statusId];
                        if (!statusGroup) continue;

                        const status = currentData.tables.statuses[statusId];
                        const isSkip = status === 'SKIP';
                        const isTimeout = status === 'TIMEOUT' || status === 'TIMEOUT-PARALLEL' || status === 'TIMEOUT-SEQUENTIAL';
                        const isFail = status && !['PASS', 'PASS-PARALLEL', 'PASS-SEQUENTIAL', 'SKIP', 'TIMEOUT', 'TIMEOUT-PARALLEL', 'TIMEOUT-SEQUENTIAL', 'EXPECTED-FAIL'].includes(status);

                        if (!statusGroup.taskIdIds) continue;

                        for (let i = 0; i < statusGroup.taskIdIds.length; i++) {
                            // Skip run-if annotations early (platform-irrelevant tests)
                            if (isSkip && currentData.tables.messages[statusGroup.messageIds?.[i]]?.startsWith('run-if')) {
                                continue; // Don't count run-if skips at all
                            }

                            const taskIdIndex = statusGroup.taskIdIds[i];
                            const jobName = currentData.tables.jobNames[currentData.taskInfo.jobNameIds[taskIdIndex]];
                            const platform = extractPlatform(jobName) || 'unknown';
                            const duration = statusGroup.durations[i];
                            const isTimeoutByDuration = status === 'UNKNOWN' && duration > 300000;

                            if (!platforms[platform]) {
                                platforms[platform] = {
                                    total: 0,
                                    skips: 0,
                                    failures: 0,
                                    timeouts: 0,
                                    passes: 0
                                };
                            }

                            platforms[platform].total++;
                            if (isSkip) {
                                platforms[platform].skips++;
                            } else if (isTimeout || isTimeoutByDuration) {
                                platforms[platform].timeouts++;
                            } else if (isFail) {
                                platforms[platform].failures++;
                            } else {
                                platforms[platform].passes++;
                            }
                        }
                    }
                }
            } else if (testData.runs) {
                // Fall back to runs if raw data is no longer available
                testData.runs.forEach(run => {
                    // Skip run-if annotations (platform-irrelevant tests)
                    if (run.isSkip && run.message?.startsWith('run-if')) {
                        return; // Don't count run-if skips at all
                    }

                    const platform = extractPlatform(run.jobName) || 'unknown';
                    if (!platforms[platform]) {
                        platforms[platform] = {
                            total: 0,
                            skips: 0,
                            failures: 0,
                            timeouts: 0,
                            passes: 0
                        };
                    }

                    platforms[platform].total++;
                    if (run.isSkip) {
                        platforms[platform].skips++;
                    } else if (run.isTimeout) {
                        platforms[platform].timeouts++;
                    } else if (run.isFail) {
                        platforms[platform].failures++;
                    } else {
                        platforms[platform].passes++;
                    }
                });
            }

            return platforms;
        }

        // Calculate platform breakdown for folder data (recursive)
        function calculateFolderPlatformBreakdown(node) {
            const platforms = {};

            // Collect from tests
            Object.values(node.tests).forEach(test => {
                const testBreakdown = calculateTestPlatformBreakdown(test.data);
                Object.entries(testBreakdown).forEach(([platform, counts]) => {
                    if (!platforms[platform]) {
                        platforms[platform] = { skips: 0, failures: 0, timeouts: 0, passes: 0, total: 0 };
                    }
                    platforms[platform].skips += counts.skips;
                    platforms[platform].failures += counts.failures;
                    platforms[platform].timeouts += counts.timeouts;
                    platforms[platform].passes += counts.passes;
                    platforms[platform].total += counts.total;
                });
            });

            // Collect from child folders
            Object.values(node.children).forEach(child => {
                const childBreakdown = calculateFolderPlatformBreakdown(child);
                Object.entries(childBreakdown).forEach(([platform, counts]) => {
                    if (!platforms[platform]) {
                        platforms[platform] = { skips: 0, failures: 0, timeouts: 0, passes: 0, total: 0 };
                    }
                    platforms[platform].skips += counts.skips;
                    platforms[platform].failures += counts.failures;
                    platforms[platform].timeouts += counts.timeouts;
                    platforms[platform].passes += counts.passes;
                    platforms[platform].total += counts.total;
                });
            });

            return platforms;
        }

        // Get skip message counts for a test (excluding run-if annotations)
        function getSkipMessageCounts(testId) {
            const messageCounts = new Map();
            if (!currentData || !currentData.testRuns || !currentData.testRuns[testId]) {
                return [];
            }

            const testGroup = currentData.testRuns[testId];

            // Find SKIP status ID
            const skipStatusId = currentData.tables.statuses.indexOf('SKIP');
            if (skipStatusId === -1) return [];

            const statusGroup = testGroup[skipStatusId];
            if (!statusGroup || !statusGroup.messageIds) return [];

            // Check if this is aggregated format
            const isAggregatedFormat = statusGroup.counts !== undefined && statusGroup.timeBuckets !== undefined;

            // Count messages, excluding run-if (platform-specific tests that are irrelevant)
            statusGroup.messageIds.forEach((messageId, i) => {
                if (messageId !== null) {
                    const message = currentData.tables.messages[messageId];
                    // Only include skip-if and other skip annotations, not run-if
                    if (message && !message.startsWith('run-if')) {
                        const count = isAggregatedFormat ? statusGroup.counts[i] : 1;
                        messageCounts.set(message, (messageCounts.get(message) || 0) + count);
                    }
                }
            });

            // Convert to array and sort by count (descending)
            return Array.from(messageCounts.entries())
                .sort((a, b) => b[1] - a[1])
                .map(([message, count]) => ({ message, count }));
        }

        // Helper to truncate long messages for display in tooltips
        function truncateMessage(message, maxLength = 100) {
            if (!message) return '';
            const firstLine = message.split('\n')[0];
            if (firstLine.length > maxLength) {
                return firstLine.substring(0, maxLength) + '...';
            } else if (message.includes('\n')) {
                return firstLine + '...';
            }
            return firstLine;
        }

        // Get failure message counts for a test
        function getFailureMessageCounts(testId) {
            const messageCounts = new Map();

            if (!currentData || !currentData.testRuns || !currentData.testRuns[testId]) {
                return [];
            }

            const testGroup = currentData.testRuns[testId];

            // Find all FAIL-* status IDs
            const failStatusIds = currentData.tables.statuses
                .map((status, idx) => status.startsWith('FAIL-') ? idx : -1)
                .filter(idx => idx !== -1);

            if (failStatusIds.length === 0) return [];

            // Collect messages from all failure statuses
            failStatusIds.forEach(statusId => {
                const statusGroup = testGroup[statusId];
                if (statusGroup && statusGroup.messageIds) {
                    // Check if this is aggregated format
                    const isAggregatedFormat = statusGroup.counts !== undefined && statusGroup.timeBuckets !== undefined;

                    statusGroup.messageIds.forEach((messageId, i) => {
                        if (messageId !== null) {
                            const message = currentData.tables.messages[messageId];
                            if (message) {
                                const count = isAggregatedFormat ? statusGroup.counts[i] : 1;
                                messageCounts.set(message, (messageCounts.get(message) || 0) + count);
                            }
                        }
                    });
                }
            });

            // Convert to array and sort by count (descending)
            return Array.from(messageCounts.entries())
                .sort((a, b) => b[1] - a[1])
                .map(([message, count]) => ({ message, count }));
        }

        // Get crash data for a test
        function getCrashData(testId) {
            if (!currentData || !currentData.testRuns || !currentData.testRuns[testId]) {
                return { signatures: [], minidumps: [] };
            }

            const testGroup = currentData.testRuns[testId];

            // Find CRASH status ID
            const crashStatusId = currentData.tables.statuses.indexOf('CRASH');
            if (crashStatusId === -1) return { signatures: [], minidumps: [] };

            const statusGroup = testGroup[crashStatusId];
            if (!statusGroup || !statusGroup.crashSignatureIds) return { signatures: [], minidumps: [] };

            // Check if this is aggregated format
            const isAggregatedFormat = statusGroup.counts !== undefined && statusGroup.timeBuckets !== undefined;

            // Collect unique signatures with counts
            const signatureCounts = new Map();
            statusGroup.crashSignatureIds.forEach((sigId, i) => {
                if (sigId !== null) {
                    const signature = currentData.tables.crashSignatures[sigId];
                    if (signature) {
                        const count = isAggregatedFormat ? statusGroup.counts[i] : 1;
                        signatureCounts.set(signature, (signatureCounts.get(signature) || 0) + count);
                    }
                }
            });

            // Collect unique minidumps (only available in detailed format)
            const minidumps = statusGroup.minidumps ? [...new Set(statusGroup.minidumps.filter(m => m !== null))] : [];

            return {
                signatures: Array.from(signatureCounts.entries())
                    .sort((a, b) => b[1] - a[1])
                    .map(([signature, count]) => ({ signature, count })),
                minidumps: minidumps
            };
        }

        // Generate tooltip content for platform breakdown
        function generateTooltipContent(platforms, type, testData, testPath) {
            // Handle timing tooltips differently
            if (['min', 'avg', 'max'].includes(type)) {
                const sortedPlatforms = Object.entries(platforms)
                    .filter(([platform, data]) => data.count > 0)
                    .sort(([,a], [,b]) => b[type] - a[type]);

                if (sortedPlatforms.length === 0) {
                    return '';
                }

                const typeLabel = type === 'min' ? 'Minimum Time' : type === 'avg' ? 'Average Time' : 'Maximum Time';
                let content = `<strong>${typeLabel} by Platform:</strong><br/>`;

                sortedPlatforms.forEach(([platform, data]) => {
                    const value = data[type];
                    const formattedValue = formatDurationMs(value, true);
                    const percentage = type === 'avg' ? '' : ` (${data.count} run${data.count !== 1 ? 's' : ''})`;
                    content += `<div class="tooltip-platform">`;
                    content += `<span class="tooltip-platform-name">${platform}:</span>`;
                    content += `<span>${formattedValue}${percentage}</span>`;
                    content += `</div>`;
                });

                return content;
            }

            // Handle regular count-based tooltips
            const sortedPlatforms = Object.entries(platforms)
                .filter(([platform, counts]) => counts[type] > 0)
                .sort(([,a], [,b]) => b[type] - a[type]);

            if (sortedPlatforms.length === 0) {
                return '';
            }

            const total = sortedPlatforms.reduce((sum, [,counts]) => sum + counts[type], 0);
            const typeLabel = type === 'failures' ? 'Failures' : type === 'skips' ? 'Skips' : 'Timeouts';

            let content = `<strong>${typeLabel} by Platform:</strong><br/>`;

            sortedPlatforms.forEach(([platform, counts]) => {
                const platformName = platforms[platform] || platform;
                const percentage = ((counts[type] / total) * 100).toFixed(1);
                content += `<div class="tooltip-platform">`;
                content += `<span class="tooltip-platform-name">${platform}:</span>`;
                content += `<span>${counts[type]} (${percentage}%)</span>`;
                content += `</div>`;
            });

            // Add skip messages for skips tooltip
            if (type === 'skips' && testData && testData.testId !== undefined) {
                const skipMessageCounts = getSkipMessageCounts(testData.testId);
                if (skipMessageCounts.length > 0) {
                    content += `<div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #555;">`;
                    content += `<strong>Skip reasons:</strong><br/>`;
                    skipMessageCounts.forEach(({message, count}) => {
                        // Remove "skip-if:" prefix and following whitespace
                        const displayMessage = message.replace(/^skip-if:\s*/, '');
                        content += `<div style="font-size: 11px; margin-top: 4px; color: #ccc;">`;
                        content += `<span style="font-family: monospace;">${escapeHtml(displayMessage)}</span>`;
                        content += ` <span style="color: #999;">(${count})</span>`;
                        content += `</div>`;
                    });
                    content += `</div>`;
                }
            }

            // Add failure messages for failures tooltip
            if (type === 'failures' && testData && testData.testId !== undefined) {
                const failureMessageCounts = getFailureMessageCounts(testData.testId);
                if (failureMessageCounts.length > 0) {
                    content += `<div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #555;">`;
                    content += `<strong>Failure messages:</strong><br/>`;
                    failureMessageCounts.forEach(({message, count}) => {
                        const displayMessage = truncateMessage(message, 100);
                        content += `<div style="font-size: 11px; margin-top: 4px; color: #ccc;">`;
                        content += `<span style="font-family: monospace; word-break: break-word;">${escapeHtml(displayMessage)}</span>`;
                        content += ` <span style="color: #999;">(${count})</span>`;
                        content += `</div>`;
                    });
                    content += `</div>`;
                }
            }

            // Add parallel failure summary at the end for failures tooltip on individual tests
            if (type === 'failures' && testData && testData.stats) {
                const stats = testData.stats;
                const parallelTotalRuns = (stats.parallelFailCount || 0) + (stats.parallelTimeoutCount || 0) + (stats.parallelPassCount || 0);
                const parallelProblematicCount = (stats.parallelFailCount || 0) + (stats.parallelTimeoutCount || 0);
                const parallelFailPercentage = stats.parallelFailPercentage || 0;

                if (parallelTotalRuns > 0) {
                    let tooltipDetails = [];
                    if (stats.parallelFailCount > 0) tooltipDetails.push(`${stats.parallelFailCount} failures`);
                    if (stats.parallelTimeoutCount > 0) tooltipDetails.push(`${stats.parallelTimeoutCount} timeouts`);

                    content += `<div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #ddd;">`;
                    content += `<strong>Parallel runs:</strong> ${parallelProblematicCount}/${parallelTotalRuns} had issues (${parallelFailPercentage}%)`;
                    if (tooltipDetails.length > 0) {
                        content += `<br/>${tooltipDetails.join(', ')}`;
                    }
                    if ((stats.sequentialPassCount || 0) > 0) {
                        content += `<br/>${stats.sequentialPassCount} sequential passes`;
                    }
                    content += `</div>`;

                    // Add per-platform parallel breakdown for tests with >= 10% parallel fail rate
                    if (parallelFailPercentage >= 10 && testPath && typeof aggregatedData !== 'undefined' && aggregatedData[testPath]) {
                        const platformBreakdown = calculateParallelPlatformBreakdown(aggregatedData[testPath]);
                        const platforms = Object.entries(platformBreakdown)
                            .filter(([platform, counts]) => (counts.parallelFails + counts.parallelTimeouts) > 0)
                            .sort(([,a], [,b]) => (b.parallelFails + b.parallelTimeouts) - (a.parallelFails + a.parallelTimeouts));

                        if (platforms.length > 0) {
                            content += `<div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #ddd;">`;
                            content += `<strong>Parallel issues by platform:</strong>`;
                            platforms.forEach(([platform, counts]) => {
                                const totalParallel = counts.parallelFails + counts.parallelTimeouts + counts.parallelPasses;
                                const problemCount = counts.parallelFails + counts.parallelTimeouts;
                                const percentage = totalParallel > 0 ? Math.round((problemCount * 100) / totalParallel) : 0;
                                content += `<br/>${platform}: ${problemCount}/${totalParallel} (${percentage}%)`;
                            });
                            content += `</div>`;
                        }
                    }
                }

                // Add crash count and breakdown
                if (testData.testId !== undefined) {
                    const crashData = getCrashData(testData.testId);
                    const totalCrashes = crashData.signatures.reduce((sum, sig) => sum + sig.count, 0);

                    if (totalCrashes > 0) {
                        content += `<div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #ddd;">`;
                        content += `<strong>Crashes: ${totalCrashes}</strong><br/>`;

                        // Add crash breakdown by platform
                        const crashesByPlatform = {};
                        if (currentData && currentData.testRuns && currentData.testRuns[testData.testId]) {
                            const testGroup = currentData.testRuns[testData.testId];
                            const crashStatusId = currentData.tables.statuses.indexOf('CRASH');
                            if (crashStatusId !== -1) {
                                const statusGroup = testGroup[crashStatusId];
                                if (statusGroup && statusGroup.taskIdIds) {
                                    for (let i = 0; i < statusGroup.taskIdIds.length; i++) {
                                        const taskIdIndex = statusGroup.taskIdIds[i];
                                        const jobName = currentData.tables.jobNames[currentData.taskInfo.jobNameIds[taskIdIndex]];
                                        const platform = extractPlatform(jobName) || 'unknown';
                                        crashesByPlatform[platform] = (crashesByPlatform[platform] || 0) + 1;
                                    }
                                }
                            }
                        }

                        const sortedPlatforms = Object.entries(crashesByPlatform)
                            .sort((a, b) => b[1] - a[1]);

                        sortedPlatforms.forEach(([platform, count]) => {
                            const percentage = ((count / totalCrashes) * 100).toFixed(1);
                            content += `<div class="tooltip-platform">`;
                            content += `<span class="tooltip-platform-name">${platform}:</span>`;
                            content += `<span>${count} (${percentage}%)</span>`;
                            content += `</div>`;
                        });

                        content += `</div>`;
                    }
                }
            }

            // Add parallel/sequential breakdown for timeouts tooltip on individual tests
            if (type === 'timeouts' && testData && testData.stats) {
                const stats = testData.stats;
                const parallelTimeouts = stats.parallelTimeoutCount || 0;
                const sequentialTimeouts = stats.sequentialTimeoutCount || 0;
                const totalTimeouts = stats.timeoutCount || 0;

                if (parallelTimeouts > 0 || sequentialTimeouts > 0) {
                    content += `<div style="margin-top: 8px; padding-top: 8px; border-top: 1px solid #ddd;">`;
                    content += `<strong>Breakdown:</strong>`;
                    if (parallelTimeouts > 0) {
                        content += `<br/>${parallelTimeouts} in parallel execution`;
                    }
                    if (sequentialTimeouts > 0) {
                        content += `<br/>${sequentialTimeouts} in sequential execution`;
                    }
                    // Show unclassified timeouts if any
                    const unclassified = totalTimeouts - parallelTimeouts - sequentialTimeouts;
                    if (unclassified > 0) {
                        content += `<br/>${unclassified} unclassified`;
                    }
                    content += `</div>`;
                }
            }

            return content;
        }

        // Build total summary row
        function buildTotalSummaryRow(totalStats) {
            // Tooltips will be computed lazily on hover

            let html = `<div class="tree-row total-row">`;
            html += `<div class="tree-name"><strong>üìä Total</strong></div>`;
            html += `<div class="tree-stats">`;

            // Check if we're showing test-specific columns or folder-specific columns
            const hasTests = treeData && Object.values(treeData.children).some(folder => Object.keys(folder.tests).length > 0);

            if (hasTests) {
                // Test view: show avg/max columns
                html += generateStatItem('Avg', '‚Äî');
                html += generateStatItem('Max', '‚Äî');
            } else {
                // Folder view: show test count
                html += generateStatItem('Tests', formatNumber(totalStats.testCount));
            }

            html += generateStatItem('Runs', formatNumber(totalStats.runCount), totalStats.runCount === 0 ? 'fail' : '');

            const totalIssuePercentageDisplay = getIssuePercentageDisplay(totalStats.issueCount, totalStats.runCount + totalStats.skipCount);
            html += generateStatItem('Issue %', totalIssuePercentageDisplay.displayValue, totalIssuePercentageDisplay.cssClass);

            // Skips with lazy tooltip
            const totalSkipContainerClass = totalStats.skipCount === 0 ? 'hideable-zero' : (totalStats.skipCount > 0 ? 'lazy-tooltip' : '');
            html += generateStatItem('Skips', formatNumber(totalStats.skipCount), 'skip', totalSkipContainerClass, '', ' data-total-root="true" data-tooltip-type="skips"');

            // Failures with lazy tooltip
            const totalFailClass = totalStats.failCount > 0 ? 'fail' : 'zero';
            const totalFailContainerClass = totalStats.failCount === 0 ? 'hideable-zero' : (totalStats.failCount > 0 ? 'lazy-tooltip' : '');
            html += generateStatItem('Failures', formatNumber(totalStats.failCount), totalFailClass, totalFailContainerClass, '', ' data-total-root="true" data-tooltip-type="failures"');

            // Timeouts with lazy tooltip
            const totalTimeoutClass = totalStats.timeoutCount > 0 ? 'timeout' : 'zero';
            const totalTimeoutContainerClass = totalStats.timeoutCount === 0 ? 'hideable-zero' : (totalStats.timeoutCount > 0 ? 'lazy-tooltip' : '');
            html += generateStatItem('Timeouts', formatNumber(totalStats.timeoutCount), totalTimeoutClass, totalTimeoutContainerClass, '', ' data-total-root="true" data-tooltip-type="timeouts"');

            html += `</div>`;
            html += `</div>`;

            return html;
        }

        // Check if a node or its children contain matches

        // Sort test list based on current sortField and sortDirection
        function sortTestList(testList) {
            return testList.sort((a, b) => {
                let valueA, valueB;

                switch(sortField) {
                    case 'name':
                        valueA = a.testPath;
                        valueB = b.testPath;
                        break;
                    case 'runCount':
                        valueA = a.stats.runCount || 0;
                        valueB = b.stats.runCount || 0;
                        break;
                    case 'issuePercentage':
                        valueA = parseFloat(a.stats.issuePercentage) || 0;
                        valueB = parseFloat(b.stats.issuePercentage) || 0;
                        break;
                    case 'issueCount':
                        valueA = a.stats.issueCount || 0;
                        valueB = b.stats.issueCount || 0;
                        break;
                    case 'skipCount':
                        valueA = a.stats.skipCount || 0;
                        valueB = b.stats.skipCount || 0;
                        break;
                    case 'failCount':
                        valueA = a.stats.failCount || 0;
                        valueB = b.stats.failCount || 0;
                        break;
                    case 'timeoutCount':
                        valueA = a.stats.timeoutCount || 0;
                        valueB = b.stats.timeoutCount || 0;
                        break;
                    case 'crashCount':
                        valueA = a.stats.crashCount || 0;
                        valueB = b.stats.crashCount || 0;
                        break;
                    default:
                        // Default sort by total issues
                        valueA = a.stats.issueCount || 0;
                        valueB = b.stats.issueCount || 0;
                        break;
                }

                if (sortField === 'name') {
                    return sortDirection === 'asc' ? valueA.localeCompare(valueB) : valueB.localeCompare(valueA);
                }

                return sortDirection === 'asc' ? valueA - valueB : valueB - valueA;
            });
        }

        // Render components view - tests grouped by bugzilla component
        function renderComponentsView() {
            if (!aggregatedData) {
                document.getElementById('no-data').style.display = 'block';
                document.getElementById('tree-container').style.display = 'none';
                return;
            }

            document.getElementById('no-data').style.display = 'none';
            document.getElementById('tree-container').style.display = 'block';

            const searchTerm = document.getElementById('search-box').value.toLowerCase().trim();

            // Group tests by component
            const componentGroups = {};
            const testsWithoutComponent = [];

            // First pass: count all tests per component (before filtering)
            const componentTotalTests = {};
            const componentTotalTestsWithIssues = {};
            for (const testPath in aggregatedData) {
                const testData = aggregatedData[testPath];
                const component = testData.component || '(no component)';
                const stats = testData.stats || computeTestStats(testData.testId);
                testData.stats = stats;

                // Count all tests
                componentTotalTests[component] = (componentTotalTests[component] || 0) + 1;

                // Count tests with issues
                if (stats.issueCount > 0) {
                    componentTotalTestsWithIssues[component] = (componentTotalTestsWithIssues[component] || 0) + 1;
                }
            }

            // Second pass: build component groups and accumulate stats
            for (const testPath in aggregatedData) {
                const testData = aggregatedData[testPath];
                const component = testData.component || '(no component)';
                const stats = testData.stats; // Already computed in first pass

                // Determine if test matches search criteria
                const componentMatchesSearch = !searchTerm || component.toLowerCase().includes(searchTerm);
                const testPathMatchesSearch = !searchTerm || testPath.toLowerCase().includes(searchTerm);
                const matchesSearch = componentMatchesSearch || testPathMatchesSearch;

                // When filtering by test name only (not component name), skip tests that don't match
                if (searchTerm && !componentMatchesSearch && !testPathMatchesSearch) {
                    continue;
                }

                // Initialize component group if needed
                if (!componentGroups[component]) {
                    componentGroups[component] = {
                        tests: [],
                        testsWithIssuesCount: 0,
                        matchingTestsCount: 0, // Count of all tests matching the filter (for "out of X")
                        totalTests: componentTotalTests[component] || 0,
                        totalTestsWithIssues: componentTotalTestsWithIssues[component] || 0,
                        totalStats: {
                            runCount: 0,
                            failCount: 0,
                            timeoutCount: 0,
                            crashCount: 0,
                            skipCount: 0,
                            passCount: 0,
                            issueCount: 0
                        }
                    };
                }

                // Count all tests that match the filter (including issue-free)
                componentGroups[component].matchingTestsCount++;

                // Accumulate stats for all tests that match the filter
                componentGroups[component].totalStats.runCount += stats.runCount || 0;
                componentGroups[component].totalStats.failCount += stats.failCount || 0;
                componentGroups[component].totalStats.timeoutCount += stats.timeoutCount || 0;
                componentGroups[component].totalStats.crashCount += stats.crashCount || 0;
                componentGroups[component].totalStats.skipCount += stats.skipCount || 0;
                componentGroups[component].totalStats.passCount += stats.passCount || 0;
                componentGroups[component].totalStats.issueCount += stats.issueCount || 0;

                // Only add test to display list if it has issues
                const hasIssues = stats.issueCount > 0;
                if (hasIssues) {
                    componentGroups[component].tests.push({ testPath, data: testData });
                    componentGroups[component].testsWithIssuesCount++;
                }
            }

            // Filter components: only show if component name matches search OR has tests to display
            const filteredComponents = Object.entries(componentGroups).filter(([componentName, group]) => {
                if (!searchTerm) return true; // No search, show all components
                const componentMatchesSearch = componentName.toLowerCase().includes(searchTerm);
                const hasMatchingTests = group.tests.length > 0;
                return componentMatchesSearch || hasMatchingTests;
            });

            // Sort components based on current sortField and sortDirection
            const sortedComponents = filteredComponents.sort(([nameA, groupA], [nameB, groupB]) => {
                let valueA, valueB;

                switch(sortField) {
                    case 'name':
                        valueA = nameA;
                        valueB = nameB;
                        break;
                    case 'runCount':
                        valueA = groupA.totalStats.runCount || 0;
                        valueB = groupB.totalStats.runCount || 0;
                        break;
                    case 'issuePercentage':
                        valueA = (groupA.totalStats.runCount + groupA.totalStats.skipCount) > 0
                            ? groupA.totalStats.issueCount / (groupA.totalStats.runCount + groupA.totalStats.skipCount)
                            : 0;
                        valueB = (groupB.totalStats.runCount + groupB.totalStats.skipCount) > 0
                            ? groupB.totalStats.issueCount / (groupB.totalStats.runCount + groupB.totalStats.skipCount)
                            : 0;
                        break;
                    case 'skipCount':
                        valueA = groupA.totalStats.skipCount || 0;
                        valueB = groupB.totalStats.skipCount || 0;
                        break;
                    case 'failCount':
                        valueA = groupA.totalStats.failCount || 0;
                        valueB = groupB.totalStats.failCount || 0;
                        break;
                    case 'timeoutCount':
                        valueA = groupA.totalStats.timeoutCount || 0;
                        valueB = groupB.totalStats.timeoutCount || 0;
                        break;
                    case 'crashCount':
                        valueA = groupA.totalStats.crashCount || 0;
                        valueB = groupB.totalStats.crashCount || 0;
                        break;
                    case 'issueCount':
                        valueA = groupA.totalStats.issueCount || 0;
                        valueB = groupB.totalStats.issueCount || 0;
                        break;
                    default:
                        // Default sort by total issues
                        valueA = groupA.totalStats.issueCount || 0;
                        valueB = groupB.totalStats.issueCount || 0;
                        break;
                }

                if (sortField === 'name') {
                    return sortDirection === 'asc' ? valueA.localeCompare(valueB) : valueB.localeCompare(valueA);
                }

                return sortDirection === 'asc' ? valueA - valueB : valueB - valueA;
            });

            // Generate HTML
            let html = '<div class="tree-table">';
            html += buildSortHeader();

            // Render each component group
            sortedComponents.forEach(([componentName, group]) => {
                const isExpanded = expandedRows.has(componentName);
                const hasIssues = group.testsWithIssuesCount > 0;

                // Component header row
                html += `<div class="tree-row folder-row ${!hasIssues ? 'non-clickable' : ''}" data-path="${escapeHtml(componentName)}">`;
                html += `<div class="tree-name">`;
                html += `<span class="folder-icon ${isExpanded ? 'expanded' : ''}"></span>`;
                html += `<strong>${escapeHtml(componentName)}</strong>`;
                if (group.testsWithIssuesCount > 0) {
                    // Determine what count to show for "out of X":
                    // - If filtering by test name: show matching tests count
                    // - Otherwise: show total tests in component
                    const isFilteringByTestName = searchTerm && group.matchingTestsCount < group.totalTests;
                    const totalCount = isFilteringByTestName ? group.matchingTestsCount : group.totalTests;

                    if (group.testsWithIssuesCount < totalCount) {
                        html += ` <span style="color: #888;">(${group.testsWithIssuesCount} test${group.testsWithIssuesCount !== 1 ? 's' : ''} with issues, out of ${totalCount})</span>`;
                    } else {
                        // All (matching) tests have issues - no need to show "out of"
                        html += ` <span style="color: #888;">(${group.testsWithIssuesCount} test${group.testsWithIssuesCount !== 1 ? 's' : ''} with issues)</span>`;
                    }
                } else {
                    html += ` <span style="color: #888;">(${group.totalTests} test${group.totalTests !== 1 ? 's' : ''})</span>`;
                }
                html += `</div>`;
                html += `<div class="tree-stats">`;

                // Show aggregate stats for component
                const totalStats = group.totalStats;
                const componentIssuePercentageDisplay = getIssuePercentageDisplay(totalStats.issueCount, totalStats.runCount + totalStats.skipCount);

                html += generateStatItem('Runs', formatNumber(totalStats.runCount));
                html += generateStatItem('Issue %', componentIssuePercentageDisplay.displayValue, componentIssuePercentageDisplay.cssClass);
                html += generateStatItem('Issues', formatNumber(totalStats.issueCount), totalStats.issueCount > 0 ? 'fail' : 'zero', totalStats.issueCount === 0 ? 'hideable-zero' : '');
                html += generateStatItem('Skips', formatNumber(totalStats.skipCount), 'skip', totalStats.skipCount === 0 ? 'hideable-zero' : '');
                html += generateStatItem('Failures', formatNumber(totalStats.failCount), totalStats.failCount > 0 ? 'fail' : 'zero', totalStats.failCount === 0 ? 'hideable-zero' : '');
                html += generateStatItem('Timeouts', formatNumber(totalStats.timeoutCount), totalStats.timeoutCount > 0 ? 'timeout' : 'zero', totalStats.timeoutCount === 0 ? 'hideable-zero' : '');
                html += generateStatItem('Crashes', formatNumber(totalStats.crashCount), totalStats.crashCount > 0 ? 'fail' : 'zero', totalStats.crashCount === 0 ? 'hideable-zero' : '');

                html += `</div>`;
                html += `</div>`;

                // Only render tests if component is expanded
                if (isExpanded) {
                    // Add component-level chart if in historical mode
                    if (isHistoricalMode) {
                        const chartId = `component-chart-${componentName.replace(/[^a-zA-Z0-9]/g, '-')}`;
                        html += `<div class="historical-chart" style="margin-left: 20px;">`;
                        html += `<canvas id="${chartId}-canvas" class="historical-chart-canvas"></canvas>`;
                        html += `<canvas id="${chartId}-skips-canvas" class="historical-chart-canvas"></canvas>`;
                        html += `</div>`;
                    }

                    // Sort tests within component by current sort order
                    const sortedTests = sortTestList(group.tests.map(t => {
                        const stats = t.data.stats || computeTestStats(t.data.testId);
                        const totalFailures = (stats.failCount || 0) + (stats.timeoutCount || 0);
                        return {
                            testPath: t.testPath,
                            stats: stats,
                            totalFailures: totalFailures
                        };
                    }));

                    // Render tests in this component (only tests with issues)
                    sortedTests.forEach(test => {
                        const testData = aggregatedData[test.testPath];
                        const hasRuns = test.stats.runCount > 0;

                        // Skip tests with no issues
                        if (test.stats.issueCount === 0) {
                            return;
                        }

                        const componentTitle = testData.component ? ` title="Component: ${escapeHtml(testData.component)}"` : '';

                        html += `<div class="tree-row test-row list-row" data-path="${test.testPath}" data-level="1">`;
                        html += `<div class="tree-name">`;
                        html += `<span class="tree-indent" style="width: 20px"></span>`;
                        html += `<span class="test-icon"></span>`;
                        html += `<span${componentTitle}>${test.testPath}</span>`;
                        html += generateTestButtons(test.testPath);
                        html += `</div>`;
                        html += `<div class="tree-stats">`;
                        html += generateStatsHtml(test.stats, test.testPath, hasRuns);
                        html += `</div>`;
                        html += `</div>`;
                    });
                }
            });

            html += '</div>';

            document.getElementById('tree-table').innerHTML = html;

            // Render component charts if in historical mode
            if (isHistoricalMode) {
                sortedComponents.forEach(([componentName, group]) => {
                    const isExpanded = expandedRows.has(componentName);
                    if (isExpanded) {
                        const chartId = `component-chart-${componentName.replace(/[^a-zA-Z0-9]/g, '-')}`;
                        const dailyData = calculateComponentDailyFailureRates(group.tests);
                        if (dailyData) {
                            createFailureRateChart(`${chartId}-canvas`, dailyData, componentName);
                        }
                    }
                });
            }

            // Add click handlers for folder rows (component headers)
            document.querySelectorAll('.folder-row:not(.non-clickable)').forEach(row => {
                row.addEventListener('click', () => toggleFolder(row));
            });

            // Add click handlers for test rows
            document.querySelectorAll('.test-row').forEach(row => {
                row.addEventListener('click', () => toggleIssueDetails(row, row.dataset.path));
            });

            // Add tooltip handlers
            document.querySelectorAll('.lazy-tooltip').forEach(element => {
                element.addEventListener('mouseenter', handleTooltipMouseEnter);
                element.addEventListener('mouseleave', handleTooltipMouseLeave);
            });
        }

        // Handle tooltip mouse enter event
        function handleTooltipMouseEnter(event) {
            const element = event.target;
            const tooltipType = element.dataset.tooltipType;

            // Determine the data source
            let platformBreakdown;
            let testData = null;
            if (element.dataset.totalRoot) {
                // Total row - calculate for entire tree
                platformBreakdown = treeData ? calculateFolderPlatformBreakdown(treeData) : {};
            } else if (element.dataset.folderPath) {
                // Folder - find the folder node and calculate breakdown
                const folderPath = element.dataset.folderPath;
                const folderNode = findFolderNode(treeData, folderPath);
                platformBreakdown = folderNode ? calculateFolderPlatformBreakdown(folderNode) : {};
            } else if (element.dataset.testPath) {
                // Test - get the test data and calculate breakdown
                const testPath = element.dataset.testPath;
                testData = aggregatedData[testPath];

                if (['min', 'avg', 'max'].includes(tooltipType)) {
                    // For timing tooltips, use the timing breakdown function
                    platformBreakdown = testData ? calculateTestPlatformTimingBreakdown(testData) : {};
                } else {
                    // For other tooltips, use the regular breakdown function
                    platformBreakdown = testData ? calculateTestPlatformBreakdown(testData) : {};
                }
            }

            // Generate and show tooltip
            const testPath = element.dataset.testPath || null;
            const tooltipContent = generateTooltipContent(platformBreakdown, tooltipType, testData, testPath);
            if (tooltipContent) {
                showTooltip(element, tooltipContent);
            }
        }

        // Handle tooltip mouse leave event
        function handleTooltipMouseLeave(event) {
            hideTooltip();
        }

        // Find folder node by path
        function findFolderNode(node, targetPath) {
            if (node.path === targetPath) {
                return node;
            }

            for (const child of Object.values(node.children)) {
                const found = findFolderNode(child, targetPath);
                if (found) return found;
            }

            return null;
        }

        // Show tooltip
        function showTooltip(element, content) {
            // Remove any existing tooltip
            hideTooltip();

            const tooltip = document.createElement('div');
            tooltip.className = 'dynamic-tooltip';
            tooltip.innerHTML = content;

            document.body.appendChild(tooltip);

            // Position tooltip near the element
            const rect = element.getBoundingClientRect();
            const tooltipRect = tooltip.getBoundingClientRect();

            // Account for scroll position
            const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
            const scrollTop = window.pageYOffset || document.documentElement.scrollTop;

            let left = rect.left + scrollLeft + (rect.width / 2) - (tooltipRect.width / 2);
            let top = rect.top + scrollTop - tooltipRect.height - 8;

            // Adjust if tooltip would go off screen (using viewport coordinates)
            if (left - scrollLeft < 8) left = scrollLeft + 8;
            if (left - scrollLeft + tooltipRect.width > window.innerWidth - 8) {
                left = scrollLeft + window.innerWidth - tooltipRect.width - 8;
            }
            if (top - scrollTop < 8) {
                top = rect.bottom + scrollTop + 8;
            }

            tooltip.style.left = left + 'px';
            tooltip.style.top = top + 'px';
        }

        // Hide tooltip
        function hideTooltip() {
            const existing = document.querySelector('.dynamic-tooltip');
            if (existing) {
                existing.remove();
            }
        }

        // Toggle folder expansion
        function toggleFolder(row) {
            const path = row.dataset.path;

            // Save scroll position before DOM changes
            const scrollTop = window.pageYOffset || document.documentElement.scrollTop;

            if (expandedRows.has(path)) {
                expandedRows.delete(path);
            } else {
                expandedRows.add(path);

                // Start loading detailed data in the background when user expands a component
                // This gives time for the large file to load before they click on individual tests
                if (isHistoricalMode) {
                    loadDetailedData();
                }
            }

            changeView();

            // Restore scroll position after DOM rebuild
            window.scrollTo(0, scrollTop);
        }

        // Toggle issue details display
        function toggleIssueDetails(row, path) {
            let existingDetailsRow = row.nextElementSibling;
            if (existingDetailsRow && existingDetailsRow.classList.contains('issue-details-row')) {
                // Remove existing details
                existingDetailsRow.remove();
            } else {
                // Close all other open test details before opening this one
                document.querySelectorAll('.issue-details-row').forEach(detailsRow => {
                    detailsRow.remove();
                });

                // Get test data
                const testData = aggregatedData[path];
                if (!testData) return;

                // Generate issue details HTML
                const detailsHtml = generateIssueDetailsHtml(path, testData);
                row.insertAdjacentHTML('afterend', detailsHtml);

                // Render chart if in historical mode
                if (isHistoricalMode && testData.testId !== undefined) {
                    const chartId = `test-chart-${testData.testId}`;
                    const dailyData = calculateDailyFailureRates(testData.testId);
                    if (dailyData) {
                        createFailureRateChart(`${chartId}-canvas`, dailyData, `${path}`);
                    }
                }
            }
        }

        // Calculate daily failure rates from historical data for a specific test
        function calculateDailyFailureRates(testId) {
            if (!isHistoricalMode || !historicalData) return null;

            const days = historicalData.metadata.days || 21;
            const startTime = historicalData.metadata.startTime;
            const dailyData = [];

            // Initialize daily data structure
            for (let day = 0; day < days; day++) {
                dailyData.push({
                    day: day,
                    date: new Date((startTime + day * 86400) * 1000).toISOString().split('T')[0],
                    passes: 0,
                    failures: 0,
                    timeouts: 0,
                    crashes: 0,
                    skips: 0
                });
            }

            const testGroup = historicalData.testRuns[testId];
            if (!testGroup) return dailyData;

            // Process each status
            for (let statusId = 0; statusId < testGroup.length; statusId++) {
                const statusGroup = testGroup[statusId];
                if (!statusGroup) continue;

                const status = historicalData.tables.statuses[statusId];

                // Check if data is in aggregated format (counts + timeBuckets)
                if (statusGroup.counts && statusGroup.timeBuckets) {
                    // Aggregated format - process by hour
                    let currentHour = 0;
                    for (let i = 0; i < statusGroup.timeBuckets.length; i++) {
                        currentHour += statusGroup.timeBuckets[i];
                        const day = Math.floor(currentHour / 24);
                        if (day < days) {
                            if (status && status.startsWith('PASS')) {
                                dailyData[day].passes += statusGroup.counts[i];
                            } else if (status === 'CRASH') {
                                dailyData[day].crashes += statusGroup.counts[i];
                            } else if (status && status.startsWith('TIMEOUT')) {
                                dailyData[day].timeouts += statusGroup.counts[i];
                            } else if (status === 'SKIP') {
                                dailyData[day].skips += statusGroup.counts[i];
                            } else if (status && status.startsWith('FAIL')) {
                                dailyData[day].failures += statusGroup.counts[i];
                            }
                        }
                    }
                } else if (statusGroup.timestamps) {
                    // Detailed format (backwards compatibility) - process individual timestamps
                    let currentTime = 0;
                    for (const diff of statusGroup.timestamps) {
                        currentTime += diff;
                        const day = Math.floor(currentTime / 86400);
                        if (day < days) {
                            if (status && status.startsWith('PASS')) {
                                dailyData[day].passes++;
                            } else if (status === 'CRASH') {
                                dailyData[day].crashes++;
                            } else if (status && status.startsWith('TIMEOUT')) {
                                dailyData[day].timeouts++;
                            } else if (status === 'SKIP') {
                                dailyData[day].skips++;
                            } else if (status && status.startsWith('FAIL')) {
                                dailyData[day].failures++;
                            }
                        }
                    }
                }
            }

            return dailyData;
        }

        // Calculate daily failure rates for an entire component (aggregate of all tests)
        function calculateComponentDailyFailureRates(componentTests) {
            if (!isHistoricalMode || !historicalData) return null;

            const days = historicalData.metadata.days || 21;
            const startTime = historicalData.metadata.startTime;
            const dailyData = [];

            // Initialize daily data structure
            for (let day = 0; day < days; day++) {
                dailyData.push({
                    day: day,
                    date: new Date((startTime + day * 86400) * 1000).toISOString().split('T')[0],
                    passes: 0,
                    failures: 0,
                    timeouts: 0,
                    crashes: 0,
                    skips: 0
                });
            }

            // Aggregate data from all tests in the component
            for (const test of componentTests) {
                const testData = test.data;
                if (!testData || testData.testId === undefined) continue;

                const testDailyData = calculateDailyFailureRates(testData.testId);
                if (!testDailyData) continue;

                // Add this test's data to the component aggregate
                for (let day = 0; day < days; day++) {
                    dailyData[day].passes += testDailyData[day].passes;
                    dailyData[day].failures += testDailyData[day].failures;
                    dailyData[day].timeouts += testDailyData[day].timeouts;
                    dailyData[day].crashes += testDailyData[day].crashes;
                    dailyData[day].skips += testDailyData[day].skips;
                }
            }

            return dailyData;
        }

        // Calculate daily failure rates for a specific issue type and message
        function calculateIssueMessageDailyRates(testId, issueType, issueMessage) {
            if (!isHistoricalMode || !historicalData) return null;

            const days = historicalData.metadata.days || 21;
            const startTime = historicalData.metadata.startTime;
            const dailyData = [];

            // Initialize daily data structure
            for (let day = 0; day < days; day++) {
                dailyData.push({
                    day: day,
                    date: new Date((startTime + day * 86400) * 1000).toISOString().split('T')[0],
                    count: 0,
                    totalRuns: 0
                });
            }

            const testGroup = historicalData.testRuns[testId];
            if (!testGroup) return dailyData;

            // First, count total runs per day for this test
            for (let statusId = 0; statusId < testGroup.length; statusId++) {
                const statusGroup = testGroup[statusId];
                if (!statusGroup) continue;

                if (statusGroup.counts && statusGroup.timeBuckets) {
                    // Aggregated format
                    let currentHour = 0;
                    for (let i = 0; i < statusGroup.timeBuckets.length; i++) {
                        currentHour += statusGroup.timeBuckets[i];
                        const day = Math.floor(currentHour / 24);
                        if (day < days) {
                            dailyData[day].totalRuns += statusGroup.counts[i];
                        }
                    }
                } else if (statusGroup.timestamps) {
                    // Detailed format (backwards compatibility)
                    let currentTime = 0;
                    for (const diff of statusGroup.timestamps) {
                        currentTime += diff;
                        const day = Math.floor(currentTime / 86400);
                        if (day < days) {
                            dailyData[day].totalRuns++;
                        }
                    }
                }
            }

            // Find the status ID for this issue type
            let targetStatusId = -1;
            for (let statusId = 0; statusId < historicalData.tables.statuses.length; statusId++) {
                const status = historicalData.tables.statuses[statusId];
                if (issueType === 'SKIP' && status === 'SKIP') {
                    targetStatusId = statusId;
                    break;
                } else if (issueType === 'FAIL' && status && status.startsWith('FAIL')) {
                    targetStatusId = statusId;
                    break;
                } else if (issueType === 'CRASH' && status === 'CRASH') {
                    targetStatusId = statusId;
                    break;
                } else if (issueType === 'TIMEOUT' && (status === 'TIMEOUT' || status && status.startsWith('TIMEOUT'))) {
                    targetStatusId = statusId;
                    break;
                }
            }

            if (targetStatusId === -1) return dailyData;

            const statusGroup = testGroup[targetStatusId];
            if (!statusGroup) return dailyData;

            // Count occurrences of this specific message by day
            if (statusGroup.counts && statusGroup.timeBuckets) {
                // Aggregated format - counts are already grouped by message/signature
                let currentHour = 0;
                for (let i = 0; i < statusGroup.timeBuckets.length; i++) {
                    currentHour += statusGroup.timeBuckets[i];
                    const day = Math.floor(currentHour / 24);

                    // Check if this occurrence matches the message we're looking for
                    let matchesMessage = false;
                    if (issueType === 'TIMEOUT') {
                        // Timeouts don't have individual messages, match all
                        matchesMessage = true;
                    } else if (issueType === 'SKIP' || issueType === 'FAIL') {
                        const messageId = statusGroup.messageIds?.[i];
                        const message = messageId !== null && messageId !== undefined ? historicalData.tables.messages[messageId] : null;
                        const cleanMessage = message ? message.replace(/^skip-if:\s*/, '') : '';

                        // Special case: match empty messages when looking for the placeholder Android message
                        if (issueMessage === FAILURE_NO_MESSAGE) {
                            matchesMessage = !cleanMessage;
                        } else {
                            matchesMessage = cleanMessage === issueMessage;
                        }
                    } else if (issueType === 'CRASH') {
                        const crashSigId = statusGroup.crashSignatureIds?.[i];
                        const crashSig = crashSigId !== null && crashSigId !== undefined ? historicalData.tables.crashSignatures[crashSigId] : null;
                        matchesMessage = crashSig === issueMessage;
                    }

                    if (matchesMessage && day < days) {
                        dailyData[day].count += statusGroup.counts[i];
                    }
                }
            } else if (statusGroup.timestamps) {
                // Detailed format (backwards compatibility) - count individual timestamps
                let currentTime = 0;
                for (let i = 0; i < statusGroup.timestamps.length; i++) {
                    currentTime += statusGroup.timestamps[i];
                    const day = Math.floor(currentTime / 86400);

                    // Check if this occurrence matches the message we're looking for
                    let matchesMessage = false;
                    if (issueType === 'TIMEOUT') {
                        // Timeouts don't have individual messages, match all
                        matchesMessage = true;
                    } else if (issueType === 'SKIP' || issueType === 'FAIL') {
                        const messageId = statusGroup.messageIds?.[i];
                        const message = messageId !== null && messageId !== undefined ? historicalData.tables.messages[messageId] : null;
                        const cleanMessage = message ? message.replace(/^skip-if:\s*/, '') : '';

                        // Special case: match empty messages when looking for the placeholder Android message
                        if (issueMessage === FAILURE_NO_MESSAGE) {
                            matchesMessage = !cleanMessage;
                        } else {
                            matchesMessage = cleanMessage === issueMessage;
                        }
                    } else if (issueType === 'CRASH') {
                        const crashSigId = statusGroup.crashSignatureIds?.[i];
                        const crashSig = crashSigId !== null && crashSigId !== undefined ? historicalData.tables.crashSignatures[crashSigId] : null;
                        matchesMessage = crashSig === issueMessage;
                    }

                    if (matchesMessage && day < days) {
                        dailyData[day].count++;
                    }
                }
            }

            return dailyData;
        }

        // Helper to get common chart options
        function getCommonChartOptions(yAxisLabel, tooltipCallback, additionalOptions = {}) {
            const options = {
                responsive: true,
                maintainAspectRatio: false,
                animation: false,
                interaction: {
                    mode: 'index',
                    intersect: false
                },
                plugins: {
                    title: { display: false },
                    legend: { display: false },
                    tooltip: {
                        animation: false,
                        callbacks: { label: tooltipCallback }
                    }
                },
                scales: {
                    x: {},
                    y: {
                        beginAtZero: true,
                        title: { display: true, text: yAxisLabel },
                        ticks: { callback: (value) => value + '%' }
                    }
                }
            };

            // Merge additional options (for stacked charts, footer callbacks, etc.)
            if (additionalOptions.stacked) {
                options.scales.x.stacked = true;
                options.scales.y.stacked = true;
            }
            if (additionalOptions.hideXAxis) {
                options.scales.x.display = false;
            }
            if (additionalOptions.tooltipFooter) {
                options.plugins.tooltip.callbacks.footer = additionalOptions.tooltipFooter;
            }

            return options;
        }

        // Create a simpler Chart.js bar chart for issue message rates over time
        function createIssueMessageChart(canvasId, dailyData, title, issueType) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return null;

            const labels = dailyData.map(d => d.date);
            const percentages = dailyData.map(d => d.totalRuns > 0 ? (d.count / d.totalRuns * 100) : 0);

            // Color based on issue type
            let backgroundColor, borderColor;
            if (issueType === 'SKIP') {
                backgroundColor = 'rgba(108, 117, 125, 0.7)';
                borderColor = '#6c757d';
            } else if (issueType === 'FAIL') {
                backgroundColor = 'rgba(255, 140, 0, 0.7)';
                borderColor = '#ff8c00';
            } else if (issueType === 'TIMEOUT') {
                backgroundColor = 'rgba(255, 193, 7, 0.7)';
                borderColor = '#ffc107';
            } else if (issueType === 'CRASH') {
                backgroundColor = 'rgba(220, 53, 69, 0.7)';
                borderColor = '#dc3545';
            } else {
                backgroundColor = 'rgba(220, 53, 69, 0.7)';
                borderColor = '#dc3545';
            }

            const yAxisLabel = issueType === 'FAIL' ? '% failures' :
                              issueType === 'TIMEOUT' ? '% timeouts' :
                              issueType === 'CRASH' ? '% crashes' :
                              issueType === 'SKIP' ? '% skips' : '% issues';

            return new Chart(canvas, {
                type: 'bar',
                data: {
                    labels: labels,
                    datasets: [{
                        label: 'Occurrence Rate',
                        data: percentages,
                        backgroundColor: backgroundColor,
                        borderColor: borderColor,
                        borderWidth: 1
                    }]
                },
                options: getCommonChartOptions(yAxisLabel, function(context) {
                    const dataIndex = context.dataIndex;
                    const data = dailyData[dataIndex];
                    const percentage = context.parsed.y.toFixed(1);

                    // Don't show 0 values in tooltip
                    if (data.count === 0) return null;

                    let typeName;
                    if (issueType === 'FAIL') {
                        typeName = data.count === 1 ? 'failure' : 'failures';
                    } else if (issueType === 'TIMEOUT') {
                        typeName = data.count === 1 ? 'timeout' : 'timeouts';
                    } else if (issueType === 'CRASH') {
                        typeName = data.count === 1 ? 'crash' : 'crashes';
                    } else if (issueType === 'SKIP') {
                        typeName = data.count === 1 ? 'skip' : 'skips';
                    } else {
                        typeName = data.count === 1 ? 'occurrence' : 'occurrences';
                    }

                    return `${formatNumber(data.count)} ${typeName} out of ${formatNumber(data.totalRuns)} runs (${percentage}%)`;
                })
            });
        }

        // Create a Chart.js bar chart showing issue rates over time
        function createFailureRateChart(canvasId, dailyData, title) {
            const canvas = document.getElementById(canvasId);
            if (!canvas) return null;

            const labels = dailyData.map(d => d.date);

            // Calculate percentages for each day
            const percentageData = dailyData.map(d => {
                const totalNonSkip = d.passes + d.failures + d.timeouts + d.crashes;
                const totalWithSkips = totalNonSkip + d.skips;
                return {
                    failureRate: totalNonSkip > 0 ? (d.failures / totalNonSkip * 100) : 0,
                    timeoutRate: totalNonSkip > 0 ? (d.timeouts / totalNonSkip * 100) : 0,
                    crashRate: totalNonSkip > 0 ? (d.crashes / totalNonSkip * 100) : 0,
                    skipRate: totalWithSkips > 0 ? (d.skips / totalWithSkips * 100) : 0
                };
            });

            // Check if we have any failures/timeouts/crashes or skips
            const hasIssues = dailyData.some(d => d.failures > 0 || d.timeouts > 0 || d.crashes > 0);
            const hasSkips = dailyData.some(d => d.skips > 0);

            // Hide/show canvases based on what data we have
            const skipCanvasId = canvasId.replace('-canvas', '-skips-canvas');
            const skipCanvas = document.getElementById(skipCanvasId);

            if (hasIssues) {
                canvas.style.display = 'block';
                // Create the failures/timeouts/crashes chart
                new Chart(canvas, {
                    type: 'bar',
                    data: {
                        labels: labels,
                        datasets: [
                            {
                                label: 'Failure %',
                                data: percentageData.map(d => d.failureRate),
                                backgroundColor: 'rgba(255, 140, 0, 0.7)',
                                borderColor: '#ff8c00',
                                borderWidth: 1
                            },
                            {
                                label: 'Timeout %',
                                data: percentageData.map(d => d.timeoutRate),
                                backgroundColor: 'rgba(255, 193, 7, 0.7)',
                                borderColor: '#ffc107',
                                borderWidth: 1
                            },
                            {
                                label: 'Crash %',
                                data: percentageData.map(d => d.crashRate),
                                backgroundColor: 'rgba(220, 53, 69, 0.7)',
                                borderColor: '#dc3545',
                                borderWidth: 1
                            }
                        ]
                    },
                    options: getCommonChartOptions('% failures', function(context) {
                        const dataIndex = context.dataIndex;
                        const data = dailyData[dataIndex];
                        const label = context.dataset.label;
                        const percentage = context.parsed.y.toFixed(1);

                        let count = 0;
                        let typeName = '';
                        if (label === 'Failure %') {
                            count = data.failures;
                            typeName = count === 1 ? 'failure' : 'failures';
                        } else if (label === 'Timeout %') {
                            count = data.timeouts;
                            typeName = count === 1 ? 'timeout' : 'timeouts';
                        } else if (label === 'Crash %') {
                            count = data.crashes;
                            typeName = count === 1 ? 'crash' : 'crashes';
                        }

                        // Don't show 0 values in tooltip
                        if (count === 0) return null;

                        const total = data.passes + data.failures + data.timeouts + data.crashes;
                        return `${formatNumber(count)} ${typeName} out of ${formatNumber(total)} runs (${percentage}%)`;
                    }, {
                        stacked: true,
                        tooltipFooter: function(tooltipItems) {
                            const dataIndex = tooltipItems[0].dataIndex;
                            const data = dailyData[dataIndex];
                            return `Passes: ${formatNumber(data.passes)}`;
                        }
                    })
                });
            } else {
                canvas.style.display = 'none';
            }

            // Create the skips chart if there are any skips
            if (hasSkips && skipCanvas) {
                skipCanvas.style.display = 'block';
                // Add class for shorter height when x-axis is hidden
                if (hasIssues) {
                    skipCanvas.classList.add('no-x-axis');
                } else {
                    skipCanvas.classList.remove('no-x-axis');
                }
                new Chart(skipCanvas, {
                    type: 'bar',
                    data: {
                        labels: labels,
                        datasets: [{
                            label: 'Skip %',
                            data: percentageData.map(d => d.skipRate),
                            backgroundColor: 'rgba(108, 117, 125, 0.7)',
                            borderColor: '#6c757d',
                            borderWidth: 1
                        }]
                    },
                    options: getCommonChartOptions('% skips', function(context) {
                        const dataIndex = context.dataIndex;
                        const data = dailyData[dataIndex];
                        const percentage = context.parsed.y.toFixed(1);

                        // Don't show 0 values in tooltip
                        if (data.skips === 0) return null;

                        const total = data.passes + data.failures + data.timeouts + data.crashes + data.skips;
                        const skipWord = data.skips === 1 ? 'skip' : 'skips';
                        return `${formatNumber(data.skips)} ${skipWord} out of ${formatNumber(total)} scheduled runs (${percentage}%)`;
                    }, {
                        hideXAxis: hasIssues  // Hide x-axis labels when showing both charts
                    })
                });
            } else if (skipCanvas) {
                skipCanvas.style.display = 'none';
            }

            return null;
        }

        // Generate HTML for issue details
        function generateIssueDetailsHtml(testPath, testData) {
            let html = `<div class="issue-details-row">`;
            html += `<div class="issue-details-content">`;

            // Add chart for historical data
            if (isHistoricalMode && testData.testId !== undefined) {
                const chartId = `test-chart-${testData.testId}`;
                html += `<div class="historical-chart">`;
                html += `<canvas id="${chartId}-canvas" class="historical-chart-canvas"></canvas>`;
                html += `<canvas id="${chartId}-skips-canvas" class="historical-chart-canvas"></canvas>`;
                html += `</div>`;
            }

            // Collect all issues into a single array
            const allIssues = [];

            // Get skip messages
            const skipMessages = getSkipMessageCounts(testData.testId);
            skipMessages.forEach(({message, count}) => {
                const displayMessage = message.replace(/^skip-if:\s*/, '');
                allIssues.push({
                    count: count,
                    type: 'SKIP',
                    message: displayMessage
                });
            });

            // Get failure messages
            const failureMessages = getFailureMessageCounts(testData.testId);
            let failureMessagesCount = 0;
            failureMessages.forEach(({message, count}) => {
                // Show full message, allow wrapping
                allIssues.push({
                    count: count,
                    type: 'FAIL',
                    message: message
                });
                failureMessagesCount += count;
            });

            // Add fallback for failures without messages (Android logging issue)
            const totalFailCount = testData.stats?.failCount || 0;
            if (totalFailCount > failureMessagesCount) {
                allIssues.push({
                    count: totalFailCount - failureMessagesCount,
                    type: 'FAIL',
                    message: FAILURE_NO_MESSAGE
                });
            }

            // Get crash data
            const crashData = getCrashData(testData.testId);
            crashData.signatures.forEach(({signature, count}) => {
                allIssues.push({
                    count: count,
                    type: 'CRASH',
                    message: signature
                });
            });

            // Get timeout data
            const timeoutCount = testData.stats?.timeoutCount || 0;
            if (timeoutCount > 0) {
                allIssues.push({
                    count: timeoutCount,
                    type: 'TIMEOUT',
                    message: 'Test exceeded time limit'
                });
            }

            if (allIssues.length === 0) {
                html += `<div class="issue-section"><p>No issues found for this test.</p></div>`;
            } else {
                // Sort by count descending
                allIssues.sort((a, b) => b.count - a.count);

                // Render single list
                html += `<div class="issue-section">`;
                allIssues.forEach(({count, type, message}, index) => {
                    const badgeClass = type === 'SKIP' ? 'badge-skip' :
                                      type === 'FAIL' ? 'badge-fail' :
                                      type === 'CRASH' ? 'badge-crash' : 'badge-timeout';
                    const issueId = `issue-${testPath.replace(/[^a-zA-Z0-9]/g, '-')}-${index}`;
                    // Store message in a way that preserves it for matching
                    const escapedMessage = message.replace(/"/g, '&quot;');
                    html += `<div class="issue-item" data-issue-id="${issueId}" data-test-path="${testPath}" data-test-id="${testData.testId}" data-issue-type="${type}" data-issue-message="${escapedMessage}" onclick="toggleIssueRuns(this, event)">`;
                    html += `<span class="issue-count">${count}</span>`;
                    html += `<span class="issue-badge ${badgeClass}">${type}</span>`;
                    html += `<span class="issue-message">${escapeHtml(message)}</span>`;
                    html += `</div>`;
                    if (isHistoricalMode) {
                        html += `<div class="historical-chart" id="${issueId}-chart" style="display: none; margin-left: 50px;">`;
                        html += `<canvas id="${issueId}-canvas" class="historical-chart-canvas"></canvas>`;
                        html += `</div>`;
                    }
                    html += `<div class="issue-runs" id="${issueId}-runs" style="display: none;"></div>`;
                });
                html += `</div>`;
            }

            html += `</div>`;
            html += `</div>`;
            return html;
        }

        // Toggle issue runs expansion
        function toggleIssueRuns(issueItem, event) {
            event.stopPropagation(); // Prevent test row toggle

            const issueId = issueItem.dataset.issueId;
            const runsDiv = document.getElementById(`${issueId}-runs`);
            const chartDiv = document.getElementById(`${issueId}-chart`);

            if (runsDiv.style.display === 'none') {
                // Expand - load and show runs
                const testId = parseInt(issueItem.dataset.testId);
                const testPath = issueItem.dataset.testPath;
                const issueType = issueItem.dataset.issueType;
                // Decode HTML entities from data attribute
                const issueMessage = issueItem.dataset.issueMessage.replace(/&quot;/g, '"');

                const runsHtml = getIssueRuns(testId, testPath, issueType, issueMessage);
                runsDiv.innerHTML = runsHtml;
                runsDiv.style.display = 'block';

                // Show and render chart if in historical mode
                if (isHistoricalMode && chartDiv) {
                    chartDiv.style.display = 'block';
                    const dailyData = calculateIssueMessageDailyRates(testId, issueType, issueMessage);
                    if (dailyData) {
                        createIssueMessageChart(`${issueId}-canvas`, dailyData, `${issueType}: ${issueMessage}`, issueType);
                    }
                }
            } else {
                // Collapse
                runsDiv.style.display = 'none';
                if (chartDiv) {
                    chartDiv.style.display = 'none';
                }
            }
        }

        // Get runs for a specific issue
        function getIssueRuns(testId, testPath, issueType, issueMessage) {
            const testGroup = currentData.testRuns[testId];
            if (!testGroup) return '<div class="issue-run-item">No run data available</div>';

            const runs = [];

            if (issueType === 'SKIP') {
                // Find SKIP status
                const skipStatusId = currentData.tables.statuses.indexOf('SKIP');
                if (skipStatusId !== -1) {
                    const statusGroup = testGroup[skipStatusId];
                    if (statusGroup && statusGroup.taskIdIds) {
                        for (let i = 0; i < statusGroup.taskIdIds.length; i++) {
                            const messageId = statusGroup.messageIds?.[i];
                            const message = messageId !== null ? currentData.tables.messages[messageId] : null;
                            const displayMessage = message ? message.replace(/^skip-if:\s*/, '') : '';

                            if (displayMessage === issueMessage) {
                                const taskIdIndex = statusGroup.taskIdIds[i];
                                const duration = statusGroup.durations?.[i];
                                runs.push(createRunInfo(taskIdIndex, issueType, testPath, duration));
                            }
                        }
                    }
                }
            } else if (issueType === 'FAIL') {
                // Find all FAIL-* statuses
                const failStatusIds = currentData.tables.statuses
                    .map((status, idx) => status.startsWith('FAIL-') ? idx : -1)
                    .filter(idx => idx !== -1);

                failStatusIds.forEach(statusId => {
                    const statusGroup = testGroup[statusId];
                    if (statusGroup && statusGroup.taskIdIds) {
                        for (let i = 0; i < statusGroup.taskIdIds.length; i++) {
                            const messageId = statusGroup.messageIds?.[i];
                            const message = messageId !== null ? currentData.tables.messages[messageId] : null;

                            if (message === issueMessage || (!message && issueMessage.includes('not recorded'))) {
                                const taskIdIndex = statusGroup.taskIdIds[i];
                                const duration = statusGroup.durations?.[i];
                                runs.push(createRunInfo(taskIdIndex, issueType, testPath, duration));
                            }
                        }
                    }
                });
            } else if (issueType === 'CRASH') {
                // Find CRASH status
                const crashStatusId = currentData.tables.statuses.indexOf('CRASH');
                if (crashStatusId !== -1) {
                    const statusGroup = testGroup[crashStatusId];
                    if (statusGroup && statusGroup.taskIdIds) {
                        for (let i = 0; i < statusGroup.taskIdIds.length; i++) {
                            const sigId = statusGroup.crashSignatureIds?.[i];
                            const signature = sigId !== null ? currentData.tables.crashSignatures[sigId] : null;

                            if (signature === issueMessage) {
                                const taskIdIndex = statusGroup.taskIdIds[i];
                                const duration = statusGroup.durations?.[i];
                                const minidump = statusGroup.minidumps?.[i];
                                runs.push(createRunInfo(taskIdIndex, issueType, testPath, duration, minidump));
                            }
                        }
                    }
                }
            } else if (issueType === 'TIMEOUT') {
                // Find TIMEOUT statuses
                const timeoutStatuses = ['TIMEOUT', 'TIMEOUT-PARALLEL', 'TIMEOUT-SEQUENTIAL'];
                timeoutStatuses.forEach(status => {
                    const statusId = currentData.tables.statuses.indexOf(status);
                    if (statusId !== -1) {
                        const statusGroup = testGroup[statusId];
                        if (statusGroup && statusGroup.taskIdIds) {
                            for (let i = 0; i < statusGroup.taskIdIds.length; i++) {
                                const taskIdIndex = statusGroup.taskIdIds[i];
                                const duration = statusGroup.durations?.[i];
                                runs.push(createRunInfo(taskIdIndex, issueType, testPath, duration));
                            }
                        }
                    }
                });
            }

            if (runs.length === 0) {
                return '<div class="issue-run-item">No matching runs found</div>';
            }

            return runs.map(run => {
                const link = run.link ? `<a href="${run.link}" target="_blank">${run.jobName}</a>` : run.jobName;
                // Don't show duration for skips (they don't run)
                const showDuration = run.issueType !== 'SKIP' && run.duration !== null && run.duration !== undefined;
                const formattedDuration = showDuration ? ` - ${formatDurationMs(run.duration, true)}` : '';
                return `<div class="issue-run-item">${link}${formattedDuration}</div>`;
            }).join('');
        }

        // Create run info object with link
        function createRunInfo(taskIdIndex, issueType, testPath, duration = null, minidump = null) {
            const taskIdString = currentData.tables.taskIds[taskIdIndex];
            const jobName = currentData.tables.jobNames[currentData.taskInfo.jobNameIds[taskIdIndex]];
            const [taskId, retryId] = taskIdString.split('.');

            let link = null;
            if (issueType === 'CRASH' && minidump) {
                const jsonUrl = `https://firefox-ci-tc.services.mozilla.com/api/queue/v1/task/${taskId}/runs/${retryId}/artifacts/public/test_info/${minidump}.json`;
                link = `crash-viewer.html?url=${encodeURIComponent(jsonUrl)}`;
            } else {
                const profileUrl = `https://firefox-ci-tc.services.mozilla.com/api/queue/v1/task/${taskId}/runs/${retryId}/artifacts/public/test_info/profile_resource-usage.json`;
                const profileName = `${jobName} (${taskIdString})`;
                const testName = testPath.split('/').pop();
                link = `https://profiler.firefox.com/from-url/${encodeURIComponent(profileUrl)}?profileName=${encodeURIComponent(profileName)}&markerSearch=${encodeURIComponent(testName)}`;
            }

            return { jobName, link, taskIdString, duration, issueType };
        }

        // Show visual feedback for successful copy
        function showCopySuccess(button) {
            const originalText = button.textContent;
            button.textContent = '‚úì';
            button.style.color = '#28a745';
            setTimeout(() => {
                button.textContent = originalText;
                button.style.color = '';
            }, 1000);
        }

        // Copy test name to clipboard
        function copyTestName(testPath) {
            const button = event.target;

            // Check if clipboard API is available (requires HTTPS or localhost)
            if (navigator.clipboard && navigator.clipboard.writeText) {
                navigator.clipboard.writeText(testPath).then(() => {
                    showCopySuccess(button);
                }).catch(() => {
                    // Fallback for clipboard API errors
                    fallbackCopyToClipboard(testPath, button);
                });
            } else {
                // Fallback when clipboard API is not available (HTTP, older browsers)
                fallbackCopyToClipboard(testPath, button);
            }
        }

        // Fallback copy function for non-HTTPS environments
        function fallbackCopyToClipboard(text, button) {
            const textArea = document.createElement('textarea');
            textArea.value = text;
            textArea.style.position = 'fixed';
            textArea.style.left = '-999999px';
            textArea.style.top = '-999999px';
            document.body.appendChild(textArea);
            textArea.focus();
            textArea.select();

            try {
                const successful = document.execCommand('copy');
                if (successful) {
                    showCopySuccess(button);
                } else {
                    console.log('Copy command returned false');
                }
            } catch (err) {
                console.error('Copy failed:', err);
            }

            document.body.removeChild(textArea);
        }

        // Change view based on radio buttons
        function changeView() {
            // Always render components view for issues page
            // Don't update hash if we're navigating (back/forward button)
            if (!isNavigating) {
                updateUrlHash();
            }
            renderComponentsView();
        }

        // Apply filtering to current view
        function applyFiltering() {
            // Always use components view for issues page
            renderComponentsView();
        }

        // Load try revision data
        async function loadTryRevision(revision = null) {
            // If no revision provided, prompt for it
            if (!revision) {
                revision = prompt('Enter try revision hash:');
                if (!revision || !revision.trim()) return;
            }

            setStatusText('Loading try revision...');
            hideError();

            try {
                const file = `xpcshell-try-${revision}.json`;
                const response = await fetchData(file);

                if (!response.ok) {
                    throw new Error(`Try revision data not found. Run: node fetch-xpcshell-data.js --try ${revision}`);
                }

                currentData = await response.json();

                // Process raw data to create test entries and tree structure
                aggregatedData = createTestEntries();
                treeData = buildTreeStructure(aggregatedData);

                // Clear date selector and show revision info
                document.getElementById('date-select').value = '';
                const jobCount = currentData.metadata.jobCount || 0;
                setStatusText(`Try: ${revision.substring(0, 12)} (${jobCount.toLocaleString()} jobs)`);

                // Update URL to include try parameter
                const url = new URL(window.location);
                url.searchParams.set('try', revision);
                window.history.replaceState({}, '', url);

                // Render the view
                changeView();
            } catch (error) {
                showError(error.message);
                setStatusText('');
            }
        }

        // Load detailed data (with taskIds) in the background
        async function loadDetailedData() {
            // Only load detailed data in historical mode
            if (!isHistoricalMode) return;

            // Don't load if already loading or loaded
            if (isLoadingDetailedData || detailedData) return;

            isLoadingDetailedData = true;
            console.log('Loading detailed data in background...');

            try {
                const response = await fetchData('xpcshell-issues-with-taskids.json');
                if (!response.ok) {
                    console.warn('Detailed data not available');
                    isLoadingDetailedData = false;
                    return;
                }

                const data = await response.json();
                detailedData = data;

                // Merge detailed data into currentData
                // The detailed data has taskIds, durations, timestamps arrays
                // We want to replace the aggregated testRuns with detailed ones
                if (currentData && currentData.testRuns) {
                    // Copy the detailed testRuns and related tables
                    currentData.testRuns = detailedData.testRuns;
                    currentData.taskInfo = detailedData.taskInfo;
                    if (detailedData.tables.taskIds) {
                        currentData.tables.taskIds = detailedData.tables.taskIds;
                    }
                    if (detailedData.tables.jobNames) {
                        currentData.tables.jobNames = detailedData.tables.jobNames;
                    }
                    if (detailedData.tables.repositories) {
                        currentData.tables.repositories = detailedData.tables.repositories;
                    }
                }

                console.log('Detailed data loaded successfully');
                isLoadingDetailedData = false;
            } catch (error) {
                console.warn('Error loading detailed data:', error);
                isLoadingDetailedData = false;
            }
        }

        // Load data from cache
        async function loadData() {
            setStatusText('Loading data...');
            hideError();

            try {
                const dateToLoad = document.getElementById('date-select').value;

                if (!dateToLoad) {
                    throw new Error('No date selected');
                }

                const file = `xpcshell-${dateToLoad}.json`;
                const response = await fetchData(file);

                if (!response.ok) {
                    throw new Error('No data available');
                }

                currentData = await response.json();

                // Process raw data to create test entries and tree structure
                aggregatedData = createTestEntries();
                treeData = buildTreeStructure(aggregatedData);

                // Update date selector and show job count
                if (currentData.metadata && currentData.metadata.date) {
                    updateDateSelector(currentData.metadata.date);
                    const jobCount = currentData.metadata.jobCount || 0;
                    setStatusText(`${jobCount.toLocaleString()} test jobs`);
                }

                changeView();
            } catch (error) {
                showError(`Error loading data: ${error.message}`, true);
            } finally {
                // Status text will show either job count (on success) or remain as loading (on error)
            }
        }

        // Toggle between historical (21 days) and single day view
        async function toggleHistoricalData() {
            const button = document.getElementById('historical-button');
            const dateSelect = document.getElementById('date-select');

            if (isHistoricalMode) {
                // Switch back to single day view
                isHistoricalMode = false;
                button.textContent = 'Show Last 21 Days';
                button.classList.remove('active');
                dateSelect.disabled = false;

                // Show date selector and label
                dateSelect.style.display = '';
                const dateLabel = dateSelect.previousElementSibling;
                if (dateLabel && dateLabel.tagName === 'LABEL') {
                    dateLabel.style.display = '';
                }

                // Clear detailed data
                detailedData = null;
                isLoadingDetailedData = false;

                // Update URL hash
                updateUrlHash();

                // Reload the currently selected date
                await loadData();
            } else {
                // Switch to historical view
                try {
                    setStatusText('Loading historical data...');
                    hideError();
                    button.disabled = true;

                    // Clear any previously loaded detailed data
                    detailedData = null;
                    isLoadingDetailedData = false;

                    const response = await fetchData('xpcshell-issues.json');
                    if (!response.ok) {
                        throw new Error('Historical data not available');
                    }

                    historicalData = await response.json();
                    currentData = historicalData; // Use historical data as current data

                    // Process the historical data
                    aggregatedData = createTestEntries();
                    treeData = buildTreeStructure(aggregatedData);

                    isHistoricalMode = true;
                    button.textContent = 'Show Single Day';
                    button.classList.add('active');
                    dateSelect.disabled = true;

                    // Hide date selector and label
                    dateSelect.style.display = 'none';
                    const dateLabel = dateSelect.previousElementSibling;
                    if (dateLabel && dateLabel.tagName === 'LABEL') {
                        dateLabel.style.display = 'none';
                    }

                    // Update status text
                    if (historicalData.metadata) {
                        const days = historicalData.metadata.days || 21;
                        const startDate = historicalData.metadata.startDate;
                        const endDate = historicalData.metadata.endDate;
                        setStatusText(`${days} days (${startDate} to ${endDate})`);
                    }

                    changeView();

                    // Update URL hash
                    updateUrlHash();
                } catch (error) {
                    showError(`Error loading historical data: ${error.message}`);
                    isHistoricalMode = false;
                } finally {
                    button.disabled = false;
                }
            }
        }

        // Update date selector
        function updateDateSelector(currentDate) {
            const select = document.getElementById('date-select');

            // Add current date if not already present
            const existingOption = Array.from(select.options).find(opt => opt.value === currentDate);
            if (!existingOption) {
                const option = document.createElement('option');
                option.value = currentDate;
                option.text = currentDate;
                option.selected = true;
                select.insertBefore(option, select.options[0]); // Insert at the beginning
            }
        }

        // Helper function to update clear button visibility (defined globally so it's accessible everywhere)
        function updateClearButton() {
            const searchBox = document.getElementById('search-box');
            const clearButton = document.getElementById('search-clear');
            clearButton.style.display = searchBox.value.trim() ? 'flex' : 'none';
        }

        // Populate date selector with available dates from index
        async function populateDateSelector() {
            const select = document.getElementById('date-select');

            try {
                const response = await fetchData('index.json');
                if (response.ok) {
                    const index = await response.json();

                    // Clear all existing options
                    select.innerHTML = '';

                    // Add all available dates
                    if (index.dates && index.dates.length > 0) {
                        index.dates.forEach((date, dateIndex) => {
                            const option = document.createElement('option');
                            option.value = date;
                            option.text = date;
                            option.selected = dateIndex === 0; // Select first (most recent) date
                            select.appendChild(option);
                        });

                        // After populating dropdown, restore state from URL hash
                        const hash = window.location.hash.slice(1);
                        if (hash) {
                            const params = new URLSearchParams(hash);

                            // Restore date selection
                            const urlDate = params.get('date');
                            if (urlDate && index.dates.includes(urlDate)) {
                                select.value = urlDate;
                            }

                            // Restore search filter
                            const search = params.get('q');
                            if (search) {
                                document.getElementById('search-box').value = search;
                                updateClearButton();
                            }
                        }
                    } else {
                        // No dates available
                        showError('No data available. Please run: node fetch-xpcshell-data.js', true);
                    }
                } else {
                    // Index file doesn't exist
                    showError('No data available. Please run: node fetch-xpcshell-data.js to fetch data.', true);
                }
            } catch (e) {
                console.warn('Could not load date index:', e);
                showError('Error loading data index. Please ensure xpcshell-data/index.json exists.', true);
            }
        }

        // Fetch new data by running the Node.js script
        async function fetchNewData() {
            showError('To fetch new data, run: node fetch-xpcshell-data.js');
        }

        // Initialize
        document.addEventListener('DOMContentLoaded', async () => {
            // Get references to search elements
            const searchBox = document.getElementById('search-box');
            const clearButton = document.getElementById('search-clear');

            // Check URL parameters for try revision
            const urlParams = new URLSearchParams(window.location.search);
            const tryRevision = urlParams.get('try');

            if (tryRevision) {
                // Load try revision from URL
                await loadTryRevision(tryRevision);
            } else {
                // Populate date selector first
                await populateDateSelector();

                // Check if we should load from URL hash
                if (window.location.hash) {
                    await loadFromUrlHash();
                } else if (document.getElementById('date-select').value) {
                    // No hash, load default date and update hash
                    updateUrlHash();
                }
            }

            // Set up search box with debouncing
            let filterTimeout;

            searchBox.addEventListener('input', function(e) {
                // Update clear button visibility
                updateClearButton();

                // Clear previous timeout
                clearTimeout(filterTimeout);

                // Debounce both the filtering operation and hash update together
                filterTimeout = setTimeout(() => {
                    // Update hash first (with current search box value)
                    if (!isNavigating) {
                        updateUrlHash();
                    }
                    // Then do the expensive filtering
                    applyFiltering();
                }, 300); // 300ms delay
            });

            // Clear button functionality
            clearButton.addEventListener('click', function() {
                searchBox.value = '';
                updateClearButton();
                clearTimeout(filterTimeout);
                applyFiltering(); // Clear filter immediately
                updateUrlHash(); // Update URL to remove q= parameter
                searchBox.focus(); // Keep focus on search box
            });

            async function loadFromUrlHash() {
                const hash = window.location.hash.slice(1); // Remove #
                const params = new URLSearchParams(hash);

                // Restore date selection (or clear if not in hash)
                const date = params.get('date');

                // Check if user wants 21-day historical view
                if (date === '21days' && !isHistoricalMode) {
                    // Enable historical mode
                    await toggleHistoricalData();
                } else if (date !== '21days' && isHistoricalMode) {
                    // Switch back to single day mode
                    await toggleHistoricalData();
                    document.getElementById('date-select').value = date || '';
                } else {
                    document.getElementById('date-select').value = date || '';
                }

                // Restore search filter (or clear if not in hash)
                // Don't update if the search box is currently focused (user is typing)
                const searchBox = document.getElementById('search-box');
                if (document.activeElement !== searchBox) {
                    const search = params.get('q');
                    searchBox.value = search || '';
                    updateClearButton();
                }
            }

            // URL hash will be loaded after the date index is fetched

            // Update hash when date changes (modify existing loadData function)
            const originalOnChange = document.getElementById('date-select').onchange;
            document.getElementById('date-select').onchange = function() {
                updateUrlHash();
                if (originalOnChange) originalOnChange.call(this);
            };

            // Handle browser back/forward buttons
            window.addEventListener('hashchange', async function() {
                isNavigating = true;

                // Cancel any pending debounced updates from search box input
                clearTimeout(filterTimeout);

                // Store the current state before loading from hash
                const previousDate = document.getElementById('date-select').value;
                const previousHistoricalMode = isHistoricalMode;

                await loadFromUrlHash();

                const newDate = document.getElementById('date-select').value;

                // Only reload data if the date changed and we're not in historical mode
                // (historical mode loads its own data in toggleHistoricalData)
                if (!isHistoricalMode && newDate && newDate !== previousDate) {
                    await loadData(); // This will also call filtering after loading data
                } else if (!isHistoricalMode && newDate && previousHistoricalMode === isHistoricalMode) {
                    applyFiltering(); // Update view with current filter state
                } else if (isHistoricalMode && previousHistoricalMode === isHistoricalMode) {
                    applyFiltering(); // Just apply filtering if already in historical mode
                }

                // Keep isNavigating true briefly to prevent the search box value change from triggering hash update
                setTimeout(() => {
                    isNavigating = false;
                }, 50);
            });
        });
    </script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
</body>
</html>
